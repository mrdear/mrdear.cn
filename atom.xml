<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>屈定&#39;s Blog</title>
  
  <subtitle>屈定&#39;s Blog - change from today</subtitle>
  <link href="https://mrdear.cn/atom.xml" rel="self"/>
  
  <link href="https://mrdear.cn/"/>
  <updated>2022-10-08T10:31:30.000Z</updated>
  <id>https://mrdear.cn/</id>
  
  <author>
    <name>Qu Ding</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>实践 -- Rome源码阅读</title>
    <link href="https://mrdear.cn/posts/work-read-rome-source.html"/>
    <id>https://mrdear.cn/posts/work-read-rome-source.html</id>
    <published>2022-10-08T10:31:33.000Z</published>
    <updated>2022-10-08T10:31:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前写了一篇<a href="https://mrdear.cn/posts/readnote-source-mybatis.html">《读书笔记 – 通用源码阅读指南》</a>，本篇是按照指南教程尝试阅读下<a href="https://github.com/rometools/rome">Rome</a>这个项目。之所以选择Rome，因为最近想要写一个RSS解析器，了解下面对多种格式有什么比较好的方式能够做到灵活扩展以及使用上的优雅兼存。我大概能够想象到这个工作量不在于难度，而在于多种格式的适配以及扩展性的兼顾，所以想要参考下Rome的实现策略，接下来按照之前定义的步骤开始阅读之旅。</p><h2 id="1-全面了解项目"><a href="#1-全面了解项目" class="headerlink" title="1. 全面了解项目"></a>1. 全面了解项目</h2><p>Rome是一个比较有历史的RSS解析工具，主要提供了以下功能：</p><ul><li>读取RSS,ATOM</li><li>输出RSS,ATOM</li><li>聚合多个RSS或者ATOM，以统一格式输出</li><li>支持扩展格式解析（module），即可以在解析或者输出过程中增加自定义转换或者标签输出<br>参考：<a href="https://rometools.github.io/rome/HowRomeWorks/index.html">https://rometools.github.io/rome/HowRomeWorks/index.html</a></li></ul><p>看到这里，不自觉会产生几个问题：</p><ol><li>如何将全部格式统一？不统一的话，每个格式之间的转换就是笛卡儿积</li><li>如何判断该使用什么解析器？</li><li>字段级解析以及输入输出怎么扩展支持？</li></ol><h2 id="2-搭建可调试环境"><a href="#2-搭建可调试环境" class="headerlink" title="2. 搭建可调试环境"></a>2. 搭建可调试环境</h2><p>该项目依赖第三方较少，git拉下来代码后，单测直接可以跑，很方便调试，这里提供一个testcase</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestReadWriter</span> <span class="keyword">extends</span> <span class="title class_">FeedTest</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TestReadWriter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;rss_2.0.xml&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> getFeedReader();</span><br><span class="line"></span><br><span class="line">        <span class="type">SyndFeedInput</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SyndFeedInput</span>();</span><br><span class="line">        <span class="type">SyndFeed</span> <span class="variable">syndFeed</span> <span class="operator">=</span> input.build(reader);</span><br><span class="line"></span><br><span class="line">        <span class="type">SyndFeedOutput</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SyndFeedOutput</span>();</span><br><span class="line">        <span class="type">StringWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringWriter</span>();</span><br><span class="line"></span><br><span class="line">        syndFeed.setFeedType(<span class="string">&quot;atom_1.0&quot;</span>);</span><br><span class="line">        output.output(syndFeed, writer);</span><br><span class="line"></span><br><span class="line">        System.out.println(writer.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-追踪项目的骨架脉络"><a href="#3-追踪项目的骨架脉络" class="headerlink" title="3. 追踪项目的骨架脉络"></a>3. 追踪项目的骨架脉络</h2><p>该项目的核心流程：读取RSS源数据 → 解析成标准格式 → 按照指定格式输出。因此按照上述的testcase，跟踪源代码绘制即可，我的绘制结果如下：</p><p><img src="https://res.mrdear.cn/blog/uPic/image-202210081813376501665224018066.png" alt="image-20221008181337650"></p><ul><li>依赖JDOM提供的SAXBuilder将XML解析成Document，再通过FeedParser解析成WireFeed类型，该类型为origin类型，存在RSS和ATOM以及OPML不同的实现类。</li><li>接下来通过Convert将WireFeed转换为SyndFeed，SyndFeed为公共类型抽象，无论底层是rss还是atom都会到这个类型来表示。</li><li>输出同理，将SyndFeed再转换为WireFeed，此时是需要输出到什么格式，就转换为具体的WireFeed实现类，最后通过WireFeedGenerator输出到XML的Document。</li></ul><h2 id="4-将源码的所有包从功能上进行划分"><a href="#4-将源码的所有包从功能上进行划分" class="headerlink" title="4.将源码的所有包从功能上进行划分"></a>4.将源码的所有包从功能上进行划分</h2><p>该项目包划分不是很细致，主要有以下几个包：</p><ul><li>util：工具类</li><li>module：利用module能力扩展出来的一些功能支持</li><li>opml：针对opml扩展出来的支持</li><li>io：主要是xml解析以及输出实现，还包含了全局的PluginManager系统</li><li>feed：rss或者atom模型的定义</li></ul><p>综合复杂度以及依赖关系：uitl → feed  → io → opml → module，因此源码阅读顺序就按照这个来。</p><p><img src="https://res.mrdear.cn/blog/uPic/image-202210081817525141665224272777.png" alt="image-20221008181752514"></p><h3 id="util包阅读"><a href="#util包阅读" class="headerlink" title="util包阅读"></a>util包阅读</h3><p>该包都是一些简单工具类方法，看了一遍后，略过。</p><h3 id="feed包阅读"><a href="#feed包阅读" class="headerlink" title="feed包阅读"></a>feed包阅读</h3><p>该包主要是定义实体类模型，比如针对RSS定义了Channel类，针对ATOM定了Feed类，以及公共抽象SyndFeed也都在这个包下面。</p><p><strong>impl包</strong></p><p>该包是利用反射能力，包装了一套bean clone能力，其核心类有：</p><ul><li>CopyFromHelper：将一个bean的属性，copy到另一个bean上，要求两个类归属一致，并且存在对应的get set方法即可</li><li>CloneableBean：针对一个bean实例提供深拷贝能力，也是get set调用获取以及设置值</li><li>EqualsBean：对比两个bean是否一致，对比实例的每一个属性值</li><li>ToStringBean：输出toString信息</li></ul><p>该包这些功能实际上可以单独给封装到另外的包，在feed下面我认为最主要的原因是这些功能都是给feed实体准备的，因为要将不同的格式统一到同一种结构上，那么势必会带来很多属性值copy。</p><p><strong>atom &amp; rss包</strong></p><ul><li>WireFeed：真实结构类parent，主要定义当前类型信息，子类有如下两者。</li><li>Feed：描述atom结构的类，都是相对于xml文件，这里会列出所有可能存在元素</li><li>Channel：描述rss结构的类，都是相对于xml文件，这里会列出所有可能存在元素</li></ul><p><strong>module包</strong></p><p>module在这里使用的并不多，更多的则是接口定义，至于有什么用处，暂时还看不出来，因此这部分遗留到module再处理。这里大致可以看出来，module是根据namespace做出来的扩展，对于一个namespace可以指定module解析，并将结果放入到Feed实例中。</p><p><strong>synd包</strong></p><ul><li>SyndFeed：用来统一不同源格式的类，其他源都能够转换到这个类。<ul><li>SyndContent：描述文本内容</li><li>SyndLink：描述链接地址</li><li>SyndImage：描述图像</li><li>SyndEntry：描述每一个Item<ul><li>SyndEnclosure：描述RSS中媒体元素</li></ul></li><li>SyndPerson：描述作者</li><li>Element：其他额外元素</li><li>Module：扩展出来的元素</li></ul></li><li>Converter：用于将原始WireFeed格式与SyndFeed转换的类，针对每一个格式有单独实现<ul><li><code>copyInto</code>：将WireFeed转换为SyndFeed</li><li><code>createRealFeed</code>：将SyndFeed转换为WireFeed</li></ul></li></ul><p>这里第一次碰到了 <code>PluginManager</code> 这个类，这个类类似于策略模式的策略管理器，Converters实现了这个类，从而有了多种Convert的管理能力，因此可以抉择最终使用哪一个Convert。PluginManager的解析，放到接下来的IO包中在看。</p><p><img src="https://res.mrdear.cn/blog/uPic/image-202210081820389401665224439212.png" alt="image-20221008182038940"></p><p><strong>IO包</strong></p><p>该包主要定义解析规则，即XML怎么到WireFeed，以及WireFeed又怎么写回RSS，同时还有WireFeed与SyndFeed之间的转换逻辑。</p><p>~ <strong>xml解析</strong></p><ul><li>XmlFixerReader：包装读取的inputstream</li><li>SAXBuilder：读取上述的inputstream</li></ul><p>~ <strong>PluginManager加载</strong></p><p>PluginManager是类似与Java的serviceload机制写的一套扩展策略管理系统，在配置中存在 <a href="http://rome.properties/">rome.properties</a> 配置文件，里面会按照如下指定了涉及到的class全类名，然后PluginManager要做的就是将这些类实例化，管理起来。</p><p>至于为什么这样设计？这样设计可以做到很灵活，因为用户也可以自己指定这个配置，来扩展自己想要的解析策略。于现在的做法，我更加倾向于简单点的一个静态Config类来管理这部分的配置。</p><p>在OSGI多类加载器下，这样的模式有点问题，用户指定的以及系统自带的可能不是一个类加载器，因此提供了 ConfigurableClassLoader 这个接口，可以指定加载使用的类加载器信息。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Converter.classes</span>=<span class="string">com.rometools.rome.feed.synd.impl.ConverterForAtom10 \</span></span><br><span class="line"><span class="string">                  com.rometools.rome.feed.synd.impl.ConverterForAtom03 \</span></span><br><span class="line"><span class="string">                  com.rometools.rome.feed.synd.impl.ConverterForRSS090 \</span></span><br><span class="line"><span class="string">                  com.rometools.rome.feed.synd.impl.ConverterForRSS091Netscape \</span></span><br><span class="line"><span class="string">                  com.rometools.rome.feed.synd.impl.ConverterForRSS091Userland \</span></span><br><span class="line"><span class="string">                  com.rometools.rome.feed.synd.impl.ConverterForRSS092 \</span></span><br><span class="line"><span class="string">                  com.rometools.rome.feed.synd.impl.ConverterForRSS093 \</span></span><br><span class="line"><span class="string">                  com.rometools.rome.feed.synd.impl.ConverterForRSS094 \</span></span><br><span class="line"><span class="string">                  com.rometools.rome.feed.synd.impl.ConverterForRSS10  \</span></span><br><span class="line"><span class="string">                  com.rometools.rome.feed.synd.impl.ConverterForRSS20</span></span><br></pre></td></tr></table></figure><p>~ <strong>解析流程</strong> </p><p>解析流程还是复用上述代码，主要分析build里面做了哪些事情。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> getFeedReader();</span><br><span class="line"><span class="type">SyndFeedInput</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SyndFeedInput</span>();</span><br><span class="line"><span class="type">SyndFeed</span> <span class="variable">syndFeed</span> <span class="operator">=</span> input.build(reader);</span><br></pre></td></tr></table></figure><ul><li>SyndFeedInput为入口类，拿到reader后，直接转交给WireFeedInput进行解析。这里是参考了Model的设计。<ul><li>WireFeedInput解析后产生的是 WireFeed</li><li>SyndFeedInput则是将 WireFeed 转换为 SyndFeed</li></ul></li><li>构建XML解析器：使用的是<code>SAXBuilder</code> ，通过xml解析得到<code>Document</code>实例</li><li>通过 FeedParsers 得到 WireFeedParser 实例，开始触发解析转换流程<ul><li>FeedParsers继承了PluginManager，通过 WireFeedParser.classes 属性key，获取对应的FeedParser实现类。</li><li>WireFeedParser中有一个 <code>boolean isMyType(final Document document)</code> 方法，该方法判断一个实例当前是否支持解析，判断依据是root元素，version，namespace等信息。<ul><li>以RSS_2.0为例：root元素为 <code>rss</code>，version为<code>2.0</code>，version不存在则默认<code>2.0</code></li></ul></li></ul></li><li>以rss_2.0解析为例，接下来就是创建Channel，然后分别解析channel以及item，补全该实例<ul><li>解析过程中，会加载module，module也是PluginManager的实现类，通过properties指定。Module分为了 root，channel类型，用于定制不同块的解析，解析后元素统一使用Module顶层类存入List中。</li></ul></li><li>使用Converter将WireFeed转换为SyndFeed实例</li></ul><p>~ <strong>输出流程</strong></p><p>输出指的是针对SyndFeed转换为xml结构。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SyndFeedOutput</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SyndFeedOutput</span>();</span><br><span class="line"><span class="type">StringWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringWriter</span>();</span><br><span class="line"></span><br><span class="line">syndFeed.setFeedType(<span class="string">&quot;atom_1.0&quot;</span>);</span><br><span class="line">output.output(syndFeed, writer);</span><br></pre></td></tr></table></figure><ul><li>同样是两层结构，SyndFeedOutput 负责将 SyndFeed 转换为 WireFeed，WireFeedOutput则是负责将WireFeed转换为xml</li><li>SyndFeed到WireFeed，同样是Converter负责转换，这里使用哪一个convert，取决于上述代码中第三行，将当前SyndFeed变更feedType，这个设计我个人觉得很不好，主要是改变原有的SyndFeed内容。</li><li>WireFeed到Document，主要使用WireFeedGenerator，这个类也是有PluginManager管理起来的，因此根据feedType可以直接选定，选定后，按照指定格式构建xml。</li></ul><h3 id="opml包阅读"><a href="#opml包阅读" class="headerlink" title="opml包阅读"></a>opml包阅读</h3><p>Opml是基于上述体系扩展出来的一个格式支持，与RSS，ATOM同等级。</p><ul><li>feed.opml：定义了opml的属性，其中Opml类继承了WireFeed</li><li>feed.synd.impl：定义了Convert，即WireFeed如何与SyndFeed转换</li><li>feed.io.iml：定义了opml解析以及输出策略类</li></ul><h3 id="module包阅读"><a href="#module包阅读" class="headerlink" title="module包阅读"></a>module包阅读</h3><p>module的核心是ModuleParser与ModuleGenerator两个类，两者都可以在properties中配置，然后嵌入到xml解析以及输出中，用于定制相关的能力，这里就不详细看了，因为觉得这种定制方式并不是很友好。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>首先回答下最初的疑问：</p><ul><li>如何将全部格式统一？不统一的话，每个格式之间的转换就是笛卡儿积<ul><li>其实格式并不是很多，atom和rss可以使用全集应对，使用顶层类来减少转换的笛卡儿积。</li></ul></li><li>如何判断该使用什么解析器？<ul><li>root，version，namespace</li></ul></li><li>字段级解析以及输入输出怎么扩展支持？<ul><li>没有发现字段级别定制能力，但可以通过module来扩展解析，只不过扩展都都统一存到List结构中，消费使用不方便</li></ul></li></ul><p>Rome的模型结构以及module扩展方式，我个人觉得使用上不是很友好，定制能力也不够强，比如针对时间字段的不同格式使用不同的解析，这个在rome中只能以自定义module来实现，但消费module结果又不那么方便。至于什么样子的既能符合使用上的直觉，有具备很强的定制能力，这个还没想好怎么处理。我的大致思路是将主体保留到实体类中，比如title，author，description，其他字段都以策略枚举的方式扩展出去，这样能够解决扩展性问题，但实用性上还没想好怎么处理，大概思路是定义特定类型访问接口，让策略枚举字段主动支持上述格式的解析。</p><p>此外这种通用源码阅读方式，针对这种简单的小项目非常适合，这样的步骤可以轻易将小项目拆解，从而完整的了解到项目全貌。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;之前写了一篇&lt;a href=&quot;https://mrdear.cn/posts/readnote-source-mybatis.html&quot;&gt;《读书笔记 – 通用源码阅读指南》&lt;/a&gt;，本篇是按照指南教程尝试阅读下&lt;a href=&quot;https://github.com/rome</summary>
      
    
    
    
    <category term="实战总结" scheme="https://mrdear.cn/categories/%E5%AE%9E%E6%88%98%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="实战" scheme="https://mrdear.cn/tags/%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记 -- 通用源码阅读指南</title>
    <link href="https://mrdear.cn/posts/readnote-source-mybatis.html"/>
    <id>https://mrdear.cn/posts/readnote-source-mybatis.html</id>
    <published>2022-10-03T06:13:06.000Z</published>
    <updated>2022-10-03T06:13:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前有看过Mybatis3相关源代码，现在无意中又看到了这本书《通用源码阅读指导书：MyBatis源码详解》，因此想要对比下自己看的思路和作者思路的差别，顺便总结出适合自己阅读源码的门路。</p><p>最早我阅读Mybatis3源码时，大概工作已经1年左右，此时经验很不成熟，也没有过多的规划，日常中使用多了就想着开始看看了。现在回想起来主要有以下两个问题：</p><ol><li>直接从框架的数据库操作主流程开始阅读，看起来很痛苦，对框架外围功能流程熟悉程度不够，因此有点瞻前顾后。</li><li>太专注细节，比如<code>TypeHandler</code> 阅读时，扣的就太细，缺少全局性把控，阅读源码最重要的是学习设计，具体实现是次要。</li></ol><p>在本书中，作者在阅读前，会先做很多辅助性功能，比如搭建好调试环境，理清楚框架脉络，以及最重要的将功能拆分，作者始终认为需要事先有一个上帝视角，然后再深入细节，这样事半功倍。接下来讲下本文的阅读流程，以及中间自己的理解。</p><h3 id="第一步：全面了解项目"><a href="#第一步：全面了解项目" class="headerlink" title="第一步：全面了解项目"></a>第一步：全面了解项目</h3><p>在开始一个项目的源码阅读前，首先需要对整个项目有较为全面的了解，需要了解项目的产生背景以及演进过程，使用方法，主要目地是勾勒出项目的整体轮廓，了解了项目的轮廓，便于更好的构建上帝视角。</p><h3 id="第二步：搭建可调试环境"><a href="#第二步：搭建可调试环境" class="headerlink" title="第二步：搭建可调试环境"></a>第二步：搭建可调试环境</h3><p>借助对项目的了解，搭建可以调试的本地开发环境，调试是非常重要，如果无法调试就意味着无法去验证项目的处理逻辑，只靠看代码，这个过程会<strong>痛苦万份</strong>。不是必要的话，针对不可调试项目，阅读源代码的必要性需要再斟酌。</p><h3 id="第三步：追踪项目的骨架脉络"><a href="#第三步：追踪项目的骨架脉络" class="headerlink" title="第三步：追踪项目的骨架脉络"></a>第三步：追踪项目的骨架脉络</h3><p>借助调试，把项目的核心流程给梳理出来，这个阶段只需要分析出项目的一个核心流程主要分成了哪些部分，之间如何配合，最好能产出每一部分的核心模块。相对复杂的逻辑，切忌不要深入，跳过就好，这个阶段重要的是形成项目的全局视角。</p><p>以Mybatis为例，核心流程如下：</p><ul><li>配置加载流程<ul><li>Configuration</li></ul></li><li>数据读写流程<ul><li>SqlSession，Executor</li></ul></li><li>结果解析流程<ul><li>ResultHandler</li></ul></li></ul><h3 id="第四步：将源码的所有包从功能上进行划分（核心）"><a href="#第四步：将源码的所有包从功能上进行划分（核心）" class="headerlink" title="第四步：将源码的所有包从功能上进行划分（核心）"></a>第四步：将源码的所有包从功能上进行划分（核心）</h3><p>这一点我认为作者的想法很好，从包结构就直接将项目的整体架构给描述的清清楚楚，能够确定哪些是核心，哪些是外围，以及之间的层次关系，前面的骨架梳理更多的目地也是产出这张模块图。以Mybatis为例，作者产出了如下的图，可以很容易看清楚里面包含了哪些模块。</p><p>这个其实变相的对所看项目提出了要求，如果所看的项目在模块上规划杂乱无章，那么自然就很难理出来这个图，留给阅读者更多痛苦，至于这种项目该不该深入研究，那就看实际所需了。</p><p><img src="https://res.mrdear.cn/blog/uPic/image-202210031436076551664778967861.png" alt="image-20221003143607655"></p><h3 id="第五步：从外围包开始阅读源码（核心）"><a href="#第五步：从外围包开始阅读源码（核心）" class="headerlink" title="第五步：从外围包开始阅读源码（核心）"></a>第五步：从外围包开始阅读源码（核心）</h3><p>源码有很多，一上来就跟着主流程看，势必很快就晕掉，因此合理的做法是先看外围包，比如Mybatis的基础功能包。先看外围包，相当于在积累一定的项目知识储备，等到了一定程度再看核心包，难度自然会降低很多。作者用了个剥洋葱的比喻，由外及内，逐层深入。</p><p>eg：基础功能包 → 配置解析包 → 核心操作包</p><h3 id="第六步：边看边思考以及记录why（核心）"><a href="#第六步：边看边思考以及记录why（核心）" class="headerlink" title="第六步：边看边思考以及记录why（核心）"></a>第六步：边看边思考以及记录why（核心）</h3><p>从外围包开始看起，可能会遇到很多设计不知道为什么，因此不了解核心逻辑。此时就需要思考和记录，等到最后看核心逻辑时，再回过来看这些，有很大可能触发恍然大悟，从而带来个人理解的质变，这样能够更好的深入理解设计原理。</p><h3 id="第七步：遇到同样本质的东西时归类总结来看"><a href="#第七步：遇到同样本质的东西时归类总结来看" class="headerlink" title="第七步：遇到同样本质的东西时归类总结来看"></a>第七步：遇到同样本质的东西时归类总结来看</h3><p>主要针对一个接口，多种实现情况下，比如MyBatis的<code>TypeHandler</code>，本质是映射，但存在非常多的映射实现，这些其实没必要看完，只需要看顶层或者抽1-2个实现来看即可。</p><h3 id="第八步：针对复杂的包，进一步按照功能拆分"><a href="#第八步：针对复杂的包，进一步按照功能拆分" class="headerlink" title="第八步：针对复杂的包，进一步按照功能拆分"></a>第八步：针对复杂的包，进一步按照功能拆分</h3><p>有些包可能很大，包含了很多功能实现，那么最好的做法是先按照功能拆分，然后按照功能分别看各自相关代码逻辑。比如Mybatis的mapping包，主要完成以下功能：</p><ul><li>SQL语句处理功能</li><li>输出结果处理功能</li><li>输入参数处理功能</li><li>多种数据库种类处理功能</li><li>其他功能</li></ul><p>这样拆分后，看起来会轻松很多。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;之前有看过Mybatis3相关源代码，现在无意中又看到了这本书《通用源码阅读指导书：MyBatis源码详解》，因此想要对比下自己看的思路和作者思路的差别，顺便总结出适合自己阅读源码的门路。&lt;/p&gt;
&lt;p&gt;最早我阅读Mybatis3源码时，大概工作已经1年左右，此时经验很不成</summary>
      
    
    
    
    <category term="读书笔记" scheme="https://mrdear.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="读书笔记" scheme="https://mrdear.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Linux -- Expect Script入门</title>
    <link href="https://mrdear.cn/posts/linux-expect_script.html"/>
    <id>https://mrdear.cn/posts/linux-expect_script.html</id>
    <published>2022-07-16T03:25:12.000Z</published>
    <updated>2022-07-16T03:25:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们习惯于在Linux上使用shell脚本自动化一些重复性的人力工作，比如批量登录远程机器并执行指定命令，或者连接ftp服务器下载指定文件。这些场景下shell难以做到完全自动化，本质原因是ssh,ftp类似程序属于交互式程序，这些程序会交互式的期望用户输入信息并响应输入。因此expect诞生了，expect是一款专门控制交互式程序的程序，我们可以用expect模拟人与程序以及终端输出(stdout)的各种交互，从而节省大量重复性人力消耗，博主用的最多的就是自动通过跳板机登录开发机，然后切换到应用目录。</p><h2 id="Expect命令"><a href="#Expect命令" class="headerlink" title="Expect命令"></a>Expect命令</h2><table><thead><tr><th align="center">Command</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">spawn</td><td align="center">通常用来启动给定程序进程，并开始与之交互，比如 <code>spawn ssh user@host</code>启动ssh进程</td></tr><tr><td align="center">expect</td><td align="center">expect命令会等待程序输出，匹配规则为正则表达式，停止条件为匹配到指定输出，程序输出结束仍然未匹配，或者达到超时时间</td></tr><tr><td align="center">expect_user</td><td align="center">对用户输入进行匹配，该指令会等待用户输入信息，然后按照指定模式将数据暂存到$expect_out数组变量中</td></tr><tr><td align="center">send</td><td align="center">将字符串输入到当前进程，该命令是交互式核心，用于模拟用户输入信息</td></tr><tr><td align="center">interact</td><td align="center">将当前进程的交互控制权转交给用户，转交给用户后，脚本不再继续执行</td></tr><tr><td align="center">send_user</td><td align="center">将信息发送到stdout，用于给用户信息提示</td></tr><tr><td align="center">set</td><td align="center">该指令既可以修改全局变量，比如<code>set timeout 10</code>修改超时时间，也可以获取命令行参数并赋值<code>set username [lindex $argv 0]</code>获取脚本参数</td></tr><tr><td align="center">close</td><td align="center">关闭当前进程</td></tr><tr><td align="center">[lindex $argv 0]</td><td align="center">获取脚本参数，0代表第一个参数，一般常配合set指令，这样后续脚本可以直接是用$xxx访问</td></tr></tbody></table><p>一般一个简单的expect脚本通常是下列形式，首先指定shebang为expect程序，然后使用spawn启动交互式程序，使用expect确定启动成功，最后使用send发送要执行的命令。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/expect</span></span><br><span class="line">spawn service username@ip_server</span><br><span class="line">expect <span class="string">&quot;last character of the command&quot;</span></span><br><span class="line">send <span class="string">&quot;your command\r&quot;</span></span><br></pre></td></tr></table></figure><h2 id="Expect案例"><a href="#Expect案例" class="headerlink" title="Expect案例"></a>Expect案例</h2><p>Expect脚本更多的是通过实例学习，博主现在掌握的实例并不多，因此本文后续会将遇到的案例追加上来，以此作为样板，读者可以根据样例实现自己的自动化逻辑</p><h3 id="简易登录ssh并执行命令"><a href="#简易登录ssh并执行命令" class="headerlink" title="简易登录ssh并执行命令"></a>简易登录ssh并执行命令</h3><p>本案例从<a href="https://sysadminote.com/how-to-learn-the-basics-of-expect-script/">How to Learn The Basics of Expect Script?</a>中摘抄出来，作为入门案例，描述了spawn，expect，send等指令的基本用法，详细分析写到注释中。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/expect -f</span></span><br><span class="line">spawn ssh root@192.168.56.227 <span class="comment"># 启动一个ssh进程</span></span><br><span class="line"><span class="built_in">set</span> <span class="built_in">timeout</span> 5 <span class="comment"># 设置全局expect超时时间，超过5s没匹配，则终止</span></span><br><span class="line">expect <span class="string">&quot;Password:&quot;</span> <span class="comment"># 匹配程序输出，期望是login，这里匹配不成功，整个脚本不会继续</span></span><br><span class="line">send <span class="string">&quot;qwerty\r&quot;</span> <span class="comment"># 执行到这里，说明expect匹配成功，send命令是向程序的输入发送qwerty，\r标识输入完毕</span></span><br><span class="line">expect <span class="string">&quot;*# &quot;</span> <span class="comment"># 匹配默认shell</span></span><br><span class="line">send <span class="string">&quot;free -m\r&quot;</span> <span class="comment"># 执行命令</span></span><br><span class="line">expect <span class="string">&quot;*# &quot;</span> <span class="comment"># 匹配默认shell</span></span><br><span class="line">send <span class="string">&quot;exit\r&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://res.mrdear.cn/uPic/linux-expect-2_1657938179.gif" alt="img"></p><h3 id="expect解析用户参数"><a href="#expect解析用户参数" class="headerlink" title="expect解析用户参数"></a>expect解析用户参数</h3><p>这个案例是大多数程序的前提，我们假设要实现一个自动化脚本，该脚本需要用户输入 host，user，password三个变量，当用户没有输入user或者password的时候，需要主动提醒，让其输入。</p><p>该脚本的核心为 <strong>set 指令获取用户参数</strong>，以及使用 <strong>expect_user 匹配用户输入</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/expect</span></span><br><span class="line"><span class="comment"># 定义变量 机器、用户、密码</span></span><br><span class="line"><span class="built_in">set</span> host <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="built_in">set</span> user <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="built_in">set</span> password <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># debug时使用</span></span><br><span class="line">send_user <span class="string">&quot;argc is <span class="variable">$argc</span>  argv is <span class="variable">$argv</span> \n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解析参数</span></span><br><span class="line"><span class="keyword">if</span> &#123; <span class="variable">$argc</span> == 3 &#125; &#123;</span><br><span class="line"><span class="comment"># 输入值为3个变量，则各自赋值</span></span><br><span class="line">    <span class="built_in">set</span> host [lindex <span class="variable">$argv</span> 0]</span><br><span class="line">    <span class="built_in">set</span> user [lindex <span class="variable">$argv</span> 1]</span><br><span class="line">    <span class="built_in">set</span> password [lindex <span class="variable">$argv</span> 2]</span><br><span class="line">&#125; elseif &#123; <span class="variable">$argc</span> == 2 &#125; &#123;</span><br><span class="line"><span class="comment"># 输入值为2个变量，为host和user</span></span><br><span class="line">    <span class="built_in">set</span> host [lindex <span class="variable">$argv</span> 0]</span><br><span class="line">    <span class="built_in">set</span> user [lindex <span class="variable">$argv</span> 1]</span><br><span class="line">&#125; elseif &#123; <span class="variable">$argc</span> == 1 &#125; &#123;</span><br><span class="line"><span class="comment"># 输入值为1个变量，为host</span></span><br><span class="line">    <span class="built_in">set</span> host [lindex <span class="variable">$argv</span> 0]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    send_user <span class="string">&quot;Invalid args!\n Usage: need \[target_home\] username password\n&quot;</span></span><br><span class="line">    <span class="built_in">exit</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">set</span> <span class="built_in">timeout</span> -1</span><br><span class="line"><span class="comment"># 如果账户密码为空</span></span><br><span class="line"><span class="keyword">if</span> &#123; <span class="variable">$user</span> == <span class="string">&quot;&quot;</span> &#125; &#123;</span><br><span class="line">    <span class="comment"># 获取用户名</span></span><br><span class="line">    send_user <span class="string">&quot;Enter your domain ID: &quot;</span></span><br><span class="line">    expect_user -re <span class="string">&quot;(.*)\n&quot;</span> <span class="comment"># 读取用户输入变量，并暂存到expect中</span></span><br><span class="line">    <span class="built_in">set</span> user <span class="string">&quot;<span class="variable">$expect_out</span>(1,string)&quot;</span> <span class="comment"># 从变量表中获取之前的输入，获取后清空</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> &#123; <span class="variable">$password</span> == <span class="string">&quot;&quot;</span> &#125; &#123;</span><br><span class="line">    <span class="comment"># 获取密码</span></span><br><span class="line">    <span class="built_in">stty</span> -<span class="built_in">echo</span> <span class="comment"># （stty -echo是屏蔽输入回显）</span></span><br><span class="line">    send_user <span class="string">&quot;Enter your password: &quot;</span></span><br><span class="line">    expect_user -re <span class="string">&quot;(.*)\n&quot;</span> </span><br><span class="line">    <span class="built_in">stty</span> <span class="built_in">echo</span></span><br><span class="line">    <span class="built_in">set</span> password <span class="string">&quot;<span class="variable">$expect_out</span>(1,string)&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># debug时使用</span></span><br><span class="line">send_user <span class="string">&quot;user is <span class="variable">$user</span>  passwd is <span class="variable">$password</span> \n&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://res.mrdear.cn/uPic/expect_1657942393.gif" alt="expect"></p><h3 id="更加完善的登录ssh判断"><a href="#更加完善的登录ssh判断" class="headerlink" title="更加完善的登录ssh判断"></a>更加完善的登录ssh判断</h3><p>该脚本相较于第一个登录案例，增加了变量，以及异常情况判断，主要用到的是<strong>expect多分支</strong>匹配。这三个案例加起来，博主觉得足以满足绝大多数情况了，况且还可以将shell和expect配合使用，在shell中调用expect脚本，以达到更加灵活的操作。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/expect</span></span><br><span class="line"><span class="comment"># 为缩短演示脚本长度，这里指定设置值，复杂情况可以配合上个案例获取参数</span></span><br><span class="line"><span class="built_in">set</span> host <span class="string">&quot;192.168.2.1&quot;</span></span><br><span class="line"><span class="built_in">set</span> user <span class="string">&quot;quding&quot;</span></span><br><span class="line"><span class="built_in">set</span> password <span class="string">&quot;quding&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> <span class="built_in">timeout</span> -1 <span class="comment"># 设置不超时，否则自动中断</span></span><br><span class="line"></span><br><span class="line">spawn ssh <span class="variable">$user</span>@<span class="variable">$host</span> <span class="comment"># 发送登录指令</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环，直到登录成功</span></span><br><span class="line"><span class="keyword">while</span> &#123;1&#125; &#123;</span><br><span class="line">    <span class="comment"># 根据返回结果发送相应命令</span></span><br><span class="line">    expect &#123;</span><br><span class="line">        <span class="comment"># 账户异常</span></span><br><span class="line">        <span class="string">&quot;Authentication failed*&quot;</span> &#123;</span><br><span class="line">            <span class="built_in">exit</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"># 添加known_ssh_host</span></span><br><span class="line">        <span class="string">&quot;(yes/no)?&quot;</span> &#123;</span><br><span class="line">            send <span class="string">&quot;yes\n&quot;</span>; exp_continue</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"># 输入密码</span></span><br><span class="line">        <span class="string">&quot;password*:&quot;</span> &#123;</span><br><span class="line">            send <span class="string">&quot;<span class="variable">$password</span>\n&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"># 匹配到用户名登录成功</span></span><br><span class="line">        <span class="string">&quot;<span class="variable">$user</span>*]&quot;</span> &#123;</span><br><span class="line">            send_user <span class="string">&quot;login success\n&quot;</span>;</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 上面登录成功后，这里可以继续执行指令</span></span><br><span class="line">send <span class="string">&#x27;date \n&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复人工交互</span></span><br><span class="line">interact</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://sysadminote.com/how-to-learn-the-basics-of-expect-script/">How to Learn The Basics of Expect Script?</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们习惯于在Linux上使用shell脚本自动化一些重复性的人力工作，比如批量登录远程机器并执行指定命令，或者连接ftp服务器下载指定文件。这些场景下shell难以做到完全自动化，本质原因是ssh,ftp类似程序属于交互式程序，这些程序会交互式的期望用户输入信息并响应输入。</summary>
      
    
    
    
    <category term="实战总结" scheme="https://mrdear.cn/categories/%E5%AE%9E%E6%88%98%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="实战" scheme="https://mrdear.cn/tags/%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>设计模式--访问者模式的思考</title>
    <link href="https://mrdear.cn/posts/design-patterns-visitor.html"/>
    <id>https://mrdear.cn/posts/design-patterns-visitor.html</id>
    <published>2022-07-03T09:13:58.000Z</published>
    <updated>2022-07-03T09:14:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>访问者模式是一个比较复杂的设计模式，他的复杂性不是由于自身，而是因为会与其他模式配合使用，两者复杂性叠加，导致逻辑很难看明白。本文主要目地是理清楚访问者模式的本质以及利弊，探究如何在业务中应用该模式的思想。</p><h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><p>访问者模式的定义为：<strong>表示一个作用于某对象结构中的各元素的操作，它可以使你在不改变元素的类的前提下定义作用于这些元素的新操作</strong>。定义是比较拗口的，简单点来说，就是在面对复杂数据结构时，可以在对应结构不感知的情况下，为该结构增加一系列的功能，比如我们平常会定义Domain类，然后在Domain Service为Domain扩展一系列的方法，这其实也算是符合访问者模式的定义，Doamin类作为输入的复杂数据结构，DomainService在不改变Domain类的情况下，给Domain增加CRUD等方法。</p><p>博主举出的这种沾亲式的案例，其实也想表达本来没有设计模式，但大家把一种策略当成模板后，设计模式就自然而然的诞生了。设计模式是编程设计原则的体现，很多人使用往往都会生搬硬套，但博主认为设计模式需要了解模式背后要解决的问题是什么，了解本质目地后，那么各种约束规则便不再是设计束缚。</p><h2 id="访问者模式的结构"><a href="#访问者模式的结构" class="headerlink" title="访问者模式的结构"></a>访问者模式的结构</h2><p><img src="https://res.mrdear.cn/uPic/image-20220702190601681_1656759962.png" alt="image-20220702190601681"></p><p>访问者模式就涉及两个关键的类，Element与Visitor，其中Element是复杂数据结构，Visitor是想要为Element增加的功能实现。</p><p><strong>Visitor</strong></p><p>上图中Visitor定义为一个访问者接口，其中含有<code>visitor(ConcreteElement1)</code>,<code>visitor(ConcreteElement2)</code>两个方法， 该接口本身不具有明确意义，只是提供了针对具象元素的访问通道，实现上具体什么含义，取决于<code>ConcreteVisitor1</code>和<code>ConcreteVisitor2</code>的实现逻辑。</p><p><strong>Element</strong></p><p>本身就是一个数据结构模型，可以是一个Model，也可以是多个Model组合而成的复杂结构。往往在不同的模型上有着差别的方法，并且需要很灵活的扩展。比如<code>ConcreteElement1</code>可能只需要分析(analysis)功能，<code>ConcreteElement2</code>则不需要分析，需要保存(save)功能。按照传统思路，要么直接在<code>ConcreteElement1</code>中增加analysis方法，要么就专为<code>ConcreteElement1</code>新建一个Service，这两种方法都存在扩展性不足的问题，因此visitor模式是为了对这两种方式进行改进而诞生的设计。</p><h2 id="简单的访问者模式"><a href="#简单的访问者模式" class="headerlink" title="简单的访问者模式"></a>简单的访问者模式</h2><p>简单的访问者模式是我自己起的名字，简化一些不必要的扩展，看看最简单的情况下访问者模式是什么样子，然后再由这种最简单的模式扩展到下面的复杂形式。这里的简化是将Element的多态给去除，假设Element就是一个实现类，那么此时每一个Visitor就相当于一个Element内部方法的迁移，接下来看具体案例。</p><p>如下图所示，假设当前Element是Dog，狗，然后我们想要给他增加健康评估(Health)和耐力预测(Endurance)技能。</p><p><img src="https://res.mrdear.cn/uPic/image-20220702194526944_1656762327.png" alt="image-20220702194526944"></p><p>首先是定义Visitor接口以及Element实体类，并分别实现通道方法<code>visit</code>和<code>accept</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 访问者接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Visitor</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接Element的通道方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(Dog dog)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义实体类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">    <span class="keyword">private</span> String ...;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义通道方法，将自身传递给访问者，让访问者能够访问自身属性</span></span><br><span class="line"><span class="comment">     * 当然这里还可以用instance of感知到具体访问者，并由此做额外的功能</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Visitor visitor)</span> &#123;</span><br><span class="line">        visitor.visit(<span class="built_in">this</span>);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来是实现具体访问者的逻辑，访问者主要是获取Element的属性，然后按照自己的逻辑实现计算，变相的为Element增加对应的能力。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 健康度计算</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HealthVisitor</span> <span class="keyword">implements</span> <span class="title class_">Visitor</span> &#123;</span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="keyword">private</span> String score;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(Dog dog)</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟获取Dog的各种指标数据，然后计算健康度</span></span><br><span class="line">        <span class="built_in">this</span>.score = 健康度(dog);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 耐力评估</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnduranceVisitor</span> <span class="keyword">implements</span> <span class="title class_">Visitor</span> &#123;</span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="keyword">private</span> String endurance;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(Dog dog)</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟获取Dog的各种指标数据，然后计算耐力</span></span><br><span class="line">        <span class="built_in">this</span>.endurance = 耐力(dog);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么定义以及实现都搞定后，想要使用什么功能，如下所示，直接初始化对应的访问者，然后用访问者调用主体类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">    dog.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    dog.setType(<span class="string">&quot;二哈&quot;</span>);</span><br><span class="line"><span class="comment">// 初始化访问者，调用实体类</span></span><br><span class="line">    <span class="type">HealthVisitor</span> <span class="variable">visitor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HealthVisitor</span>();</span><br><span class="line">    visitor.visit(dog);</span><br><span class="line">    </span><br><span class="line">    System.out.println(visitor.getScore());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看完上述实现，我们可以分析下这个简单案例。如果不使用访问者模式，那么可以新建一个DogDomainService，然后在Service中实现健康评估(Health)和耐力预测(Endurance)技能，这种方式也是可以的，当功能更加复杂后，将其用访问者模式分离开功能，每个复杂功能单独实现，像是插件一样，想要扩展时，也只需要新增加一个Visitor的实现策略，也是合理的。因此访问者模式的本质目地之一我们可以简单的认为就是将原本的属于Element的功能给拆散到Visitor中，便于后续灵活扩展。当然这样的简单案例发挥不出访问模式的优势，这种扩展一般策略模式就足以了，接下来看下多主体类下的访问者模式。</p><h2 id="多主体类的访问者模式"><a href="#多主体类的访问者模式" class="headerlink" title="多主体类的访问者模式"></a>多主体类的访问者模式</h2><p>与上述访问者模式不同的是，多主体模式下的Element是多继承结构，比如Animal下面分为了狗(Dog)以及猫(Cat)还有鹦鹉(Parrot)等等，每个不同的Element具有特殊的功能，比如猫(Cat)的攀爬(scramble)能力，鹦鹉(Parrot)的飞行(flight)能力，那么此时Visitor接口本身还是具有通用通道，访问者的具体实现类就根据自身需要，具有针对性的实现对应方法，一般依赖多态来分别实现区分不同的功能。</p><p><img src="https://res.mrdear.cn/uPic/image-20220703114253495_1656819773.png" alt="image-20220703114253495"></p><p>如上图所示：此时Element被分为了Animal接口，以及三个实现类：Dog，Cat，Parrot。Visitor接口中分别增加了对三类主体的访问方法：visit(Dog)，visit(Cat)，visit(Parrot)。其中实现类HealthVisitor，EnduranceVisitor可以同时对三者进行健康评估和耐力评估，ScrambleVisitor只针对Cat做攀爬能力分析，FlightVisitor则只针对Parrot做飞行能力分析。</p><p>案例很好理解，就是上面的变种，因此就不展示具体代码了，这里我们分析下引入多主体类后，会产生哪些问题。</p><p><strong>问题一</strong>：Visitor中对每个类都有个visitor方法，目地是什么？</p><p>这个问题想必是很多人的疑问，Visitor接口承担的是一个通道的作用，重载方法的定义是为了<strong>方法调用的一致性</strong>，只需要visit(xxx)以及accept(xxx)。当然也可以直接定义一个visit(Animal)，但这样子类由需要instance of感知具体的Element是什么，才能进行单独的逻辑，反而增加复杂性，直观性也不足够，比如想找到所有给Dog增加的方法，就比较麻烦，不像有单独接口，可以直接定位到子类，得不偿失。</p><p><strong>问题二</strong>：Visitor子类如何方便的选择自己针对的Element？</p><p>上述方式带来的弊端是子类感知到了所有的方法，像FlightVisitor这种实现类，只针对Parrot，他就不需要感知visit(Dog&#x2F;Cat)，此时一般会在Visitor接口下面增加一个VisitorAdapter抽象类，来实现所有的方法，只不过实现的逻辑都是Throw UnSupportException，然后子类再选择自己想要覆盖的实现。在或者将visit(Dog)，visit(Cat)，visit(Parrot)分别拆分到三个Visitor接口：DogVisitor，CatVisitor，ParrotVisitor，然后实现类利用多重继承，选择实现对应的接口，也是一种合理方式。</p><p><strong>问题三</strong>：Visitor与Element之间的耦合关系是什么样子？</p><p>耦合关系决定了使用形式，从上述关系图来看，Element是不感知Visitor的，也就是具体有哪些Visitor，Element毫不关心，但反过来Visitor是强感知Element的，Visitor需要知道自己针对的是哪个Element，不针对哪些Element。这样的关系决定了我们在使用访问者模式时，是需要知道当下业务到底想要什么样子的Visitor。比如当前就需要对鹦鹉(Parrot)做飞行评估，那么就需要主动实例化出来FlightVisitor。</p><h2 id="嵌套其他模式的访问者模式"><a href="#嵌套其他模式的访问者模式" class="headerlink" title="嵌套其他模式的访问者模式"></a>嵌套其他模式的访问者模式</h2><p>这个是在实际开发过程中用到的最多的一种情况了，因此基于上面两个案例的铺垫，这里会直接使用实际案例来进行分析。</p><p>在SQL解析中，一般会经过词法分析，语法／语义分析（生成AST语法树），各种业务自定义逻辑（比如分库分表表名替换）这几个步骤，参考美团文章中的图，针对如下SQL会生成对应AST语法树：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> username, ismale <span class="keyword">from</span> userinfo <span class="keyword">where</span> age <span class="operator">&gt;</span> <span class="number">20</span> <span class="keyword">and</span> level <span class="operator">&gt;</span> <span class="number">5</span> <span class="keyword">and</span> <span class="number">1</span> <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p><img src="https://res.mrdear.cn/uPic/a74c9e9c_1656837542.png" alt="图2 语法树"></p><p>这种树形结构，在应用中一般以<a href="https://mrdear.cn/posts/design-patterns-composite.html">组合模式</a>形式构建，以Druid为例，解析后结构如下图所示，应用对外展示的则是最顶层的<code>SQLStatement</code>，其本质是<code>SQLSelectStatement</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select username, ismale from userinfo where age &gt; 20 and level &gt; 5 and 1 = 1&quot;</span>;</span><br><span class="line"><span class="comment">// 新建 MySQL Parser</span></span><br><span class="line"><span class="type">SQLStatementParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MySqlStatementParser</span>(sql);</span><br><span class="line"><span class="comment">// 使用Parser解析生成AST，这里SQLStatement就是AST</span></span><br><span class="line"><span class="type">SQLStatement</span> <span class="variable">sqlStatement</span> <span class="operator">=</span> parser.parseStatement();</span><br></pre></td></tr></table></figure><p><img src="https://res.mrdear.cn/uPic/image-20220703164319627_1656837799.png" alt="image-20220703164319627"></p><p>运用<a href="https://mrdear.cn/posts/design-patterns-composite.html">组合模式</a>提供的嵌套能力，可以很轻松的将这个AST语法树给构建出来，但问题是怎么方便的访问？比如从上述语句中提取出来表名，就需要从顶层Select节点遍历到From节点，然后获取表名，如果再嵌套子查询，那么情况更加复杂。因此实际情况下，更多时候使用Visitor模式做组合对象的功能扩展，接下来我们使用Druid提供的Visitor接口，实现一个表名提取器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个表名提取的visitor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TableNameVisitor</span> <span class="keyword">implements</span> <span class="title class_">SQLASTVisitor</span> &#123;</span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    List&lt;String&gt; tables = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">visit</span><span class="params">(SQLExprTableSource x)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">tableName</span> <span class="operator">=</span> x.getTableName();</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != tableName) &#123;</span><br><span class="line">            tables.add(tableName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该Visitor实现了<code>SQLASTVisitor</code>接口，这个是Druid预留的扩展，里面针对每一个组合中的实体类Element提供了Visitor通道，比如这里访问表名，只需要实现<code>visit(SQLExprTableSource x)</code>来访问表来源相关的语法节点即可。接下来使用该Visitor遍历语法树：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select username, ismale from userinfo where age &gt; 20 and level &gt; 5 and 1 = 1&quot;</span>;</span><br><span class="line">    <span class="comment">// 新建 MySQL Parser</span></span><br><span class="line">    <span class="type">SQLStatementParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MySqlStatementParser</span>(sql);</span><br><span class="line">    <span class="comment">// 使用Parser解析生成AST，这里SQLStatement就是AST</span></span><br><span class="line">    <span class="type">SQLStatement</span> <span class="variable">sqlStatement</span> <span class="operator">=</span> parser.parseStatement();</span><br><span class="line">    <span class="comment">// 使用访问者去遍历语法树</span></span><br><span class="line">    <span class="type">TableNameVisitor</span> <span class="variable">visitor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TableNameVisitor</span>();</span><br><span class="line">    sqlStatement.accept(visitor);</span><br><span class="line">    System.out.println(<span class="string">&quot;getTables:&quot;</span> + visitor.getTables());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历的过程只需要调用SQLStatement.accept(visitor)，该节点会自动顺着语法树的顶层，一直遍历，直到每一个叶子节点。</p><h2 id="模式总结"><a href="#模式总结" class="headerlink" title="模式总结"></a>模式总结</h2><p>到这里，针对Visitor模式的本质基本上差不多了，Visitor模式的复杂性来源博主认为主要有两点：1）主体类Element本身是多重继承结构，或者是组合模式这种复合型结构，不符合人的直观思维，增加理解难度。2）Visitor的实现类是分散开的，且都是一个个独立的功能，不能很直观的展示一个对象究竟有哪些能力，也增加理解成本。</p><p>大多数时候，使用Visitor模式扩展必要性是不大的，策略模式就能满足了。但在最后一个案例中，如果没有Visitor模式，笔者还真的想象不到有什么好的方式能够解决组合模式的扩展性问题，这大概也是在实际开发中看到的Visitor模式都是和组合模式一起出现的原因。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://book.douban.com/subject/5343318/">《研磨设计模式》- 访问者模式</a></p><p><a href="https://tech.meituan.com/2018/05/20/sql-parser-used-in-mtdp.html">SQL解析在美团的应用</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;访问者模式是一个比较复杂的设计模式，他的复杂性不是由于自身，而是因为会与其他模式配合使用，两者复杂性叠加，导致逻辑很难看明白。本文主要目地是理清楚访问者模式的本质以及利弊，探究如何在业务中应用该模式的思想。&lt;/p&gt;
&lt;h2 id=&quot;访问者模式&quot;&gt;&lt;a href=&quot;#访问者模</summary>
      
    
    
    
    <category term="设计模式专题" scheme="https://mrdear.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%93%E9%A2%98/"/>
    
    
    <category term="设计模式" scheme="https://mrdear.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记 -- 《Maven实战》</title>
    <link href="https://mrdear.cn/posts/readnote-maven_in_action.html"/>
    <id>https://mrdear.cn/posts/readnote-maven_in_action.html</id>
    <published>2022-02-01T12:36:35.000Z</published>
    <updated>2022-02-01T12:36:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间Maven更新到了3.8.1版本，该版本只支持HTTPS协议仓库，公司内部升级后又需要重新将配置修改一番，然而修改过程并不容易，由于不了解Maven的配置与定位jar的关系，只能不断试错重来。想到使用Maven这么多年，每次都是直接copy别人的配置，随便改改以及替换URL，是时候好好去了解下了。</p><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><ul><li>maven资源标识：groupId-artifactId-version-packageing-classifier，通常packageing为jar，classifier不指定。</li><li>maven的仓库：<ul><li>本地仓库：<code>$&#123;user.home&#125;/.m2/repository</code> </li><li>中央仓库：id默认为central，地址为<code>http://repo1.maven.org/maven2</code> </li><li>聚合仓库：第三方开放的Maven仓库，如阿里云，腾讯云等提供的加速库</li></ul></li></ul><p>这里很核心的一点：中央仓库(id&#x3D;central)是一个特有的概念和定位，他是Maven资源的首要来源，central的配置在超级pom中，因此其等级是优先于聚合仓库低于本地仓库。</p><h2 id="查找流程"><a href="#查找流程" class="headerlink" title="查找流程"></a>查找流程</h2><p>整个查找流程如下图所示：</p><ul><li>查找本地repository</li><li>查找id&#x3D;central仓库，该过程会使用servers做认证，使用mirrors做拉取地址替换</li><li>根据release以及snapshot的配置，查找其他仓库，该过程同样使用servers以及mirrors做认证以及地址替换</li></ul><p><img src="https://res.mrdear.cn/uPic/image-20220201211136346_1643721096.png" alt="image-20220201211136346"></p><h2 id="如何配置合理？"><a href="#如何配置合理？" class="headerlink" title="如何配置合理？"></a>如何配置合理？</h2><p>从上面流程来看，Maven的配置逻辑本身很简单，但在一些公司中，Maven配置的复杂性主要来源于仓库众多，以蚂蚁为例，官方的仓库就有7个左右，新同学接手时，就很容易出现错误，那么怎么配置呢？</p><p><strong>1. 选定中央仓库代理</strong></p><p>中央仓库自然优先级最高，默认的<code>http://repo1.maven.org/maven2</code> 由于网络原因，拉取常常出现中断，因此中央仓库一般使用mirrors方式定向到国内镜像，而<strong>不是复写repository配置</strong>，比如下方我使用的阿里云仓库。</p><p>这里需要注意下<code>&lt;mirrorOf&gt;</code>，国内很多加速库会推荐设置为*，代表代理所有仓库，这种当然是不负责的推荐配置，阿里云的public库只是central以及jcenter的聚合，并不能代替spring,gradle,jetbrain等仓库。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">id</span>&gt;</span>mirror<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central,jcenter<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">name</span>&gt;</span>mirror<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>2. 使用Profile划分其他仓库</strong></p><p>profile用于圈定一批生效仓库，比如下方我定义了一个rdc profile作为默认生效的配置，其中的repositories分别配置了私有的releases&amp;snapshot库，如果有多个release或者snapshot，那么只需要在该配置中增加即可。如果独立环境的仓库，那么可以新建一个profile圈选，在IDE中做快捷切换。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>rdc<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>rdc-releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://packages.aliyun.com/maven/repository/2184158-release-WRgrWp/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>rdc-snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://packages.aliyun.com/maven/repository/2184158-snapshot-3P70Vz/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前段时间Maven更新到了3.8.1版本，该版本只支持HTTPS协议仓库，公司内部升级后又需要重新将配置修改一番，然而修改过程并不容易，由于不了解Maven的配置与定位jar的关系，只能不断试错重来。想到使用Maven这么多年，每次都是直接copy别人的配置，随便改改以及替</summary>
      
    
    
    
    <category term="读书笔记" scheme="https://mrdear.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="读书笔记" scheme="https://mrdear.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>存储技术 -- SSD原理简介</title>
    <link href="https://mrdear.cn/posts/storage-ssd.html"/>
    <id>https://mrdear.cn/posts/storage-ssd.html</id>
    <published>2021-05-05T06:40:52.000Z</published>
    <updated>2021-05-05T06:40:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近开始读《深入浅出SSD-固态存储核心技术》等相关存储原理的书籍，本文是根据书内容所做的总结，解答了博主多年以来对存储方面的疑惑，希望本文对你有帮助。</p><h2 id="SSD物理结构"><a href="#SSD物理结构" class="headerlink" title="SSD物理结构"></a>SSD物理结构</h2><p>SSD (Solid State Drive)：即固态硬盘，是一种以半导体(NAND Flash)为介质的存储设备。从物理结构上来看，有以下几个组件：</p><ul><li>接口：用于与计算机等设备相连</li><li>主控：本质上也是一颗小型CPU，负责数据读取，写入以及SSD自身维护等</li><li>缓存DRAM：用于一些加速场景，比如映射表缓存 </li><li>闪存：实际数据存储区域</li><li>PCB(电源，电容等)：电源管理</li></ul><p>因此可以大致想象整个工作方式如下图所示：主机通过接口将<strong>数据</strong>提交到SSD，SSD<strong>主控</strong>首先决定数据到底存储在<strong>闪存</strong>的什么位置，然后再将数据写入到具体的<strong>闪存</strong>位置中。</p><p><img src="https://res.mrdear.cn/uPic/image-20210504213628535_1620135389.png" alt="image-20210504213628535"></p><p>SSD使用的闪存芯片其内部由许许多多存储单元构成，每一个存储单元是浮栅晶体管结构，对于该结构我们只需要知道其可以存储电子，且断电后电子不会消失，也因此SSD为非易失性存储器。从数据的角度，所谓的写数据，是控制电子数量来标识状态，读数据则是加电压，获取对应的状态。随着SSD不断的发展，一个存储单元能够标识的bit位数据在不断增加，将SSD颗粒分为SLC，MLC，TLC，QLC，分别对应1bit，2bit，3bit，4bit，其速度以及寿命随着bit位数增加而<strong>减少</strong>，但容量不断<strong>增大</strong>，当然成本也在逐渐<strong>降低</strong>，时至今日，SSD已经很接近与HDD的价格了。</p><p><img src="https://res.mrdear.cn/uPic/image-20210504221045333_1620137445.png" alt="image-20210504221045333"></p><p>那么如何理解这发展现象？举个例子，当一个存储单元只需要表示1bit位数时，可以很简单的认为电子数大于0，标识1，小于等于0标识0，那么无论是加电压判断还是清空电子逻辑都方便很多。当需要表示2bit时，可以认为当<strong>电子数&gt;&#x3D;3</strong>时，为11，3&gt;电子数&gt;&#x3D;2时标识10，<strong>2&gt;电子数&gt;&#x3D;1</strong>时标识01，电子数为0时标识0，那么要准确判断数据到底是什么自然就麻烦了很多，因此随着bit表示增加，实际情况只会更加复杂，因此性能是逐渐下降的。</p><p>但随之带来的好处是成本的下降，在1bit存储单元时代，大容量的SSD只能依赖工艺的提升，在一个闪存芯片中塞入更多的存储单元，但带来的容量却很有限，然而牺牲部分速度前提下，一个存储单元标识2bit，相同面积下容量直接翻倍，这是SSD能够普及消费者市场的重要推力。</p><h2 id="SSD数据存储结构"><a href="#SSD数据存储结构" class="headerlink" title="SSD数据存储结构"></a>SSD数据存储结构</h2><p>大容量的SSD，一般由多个NAND Flash所组成，这里单独看一个NAND Flash。</p><p>最外层被称为DIE&#x2F;LUN，该部分是接收与执行闪存命令的基本单元，一个LUN又由多个Plane所构成，Plane是真正执行数据读写单元，因此具备独立的Cache Register以及Page Register，一个Plane由多个Block所构成，Block是数据擦除的基本单位，由于擦除需要较高电压，因此在Block层面是比较妥协的做法，Block由多个Page构成，一个Page一般4KB，Page是最基本的数据读写单位。这里直接借用书中的图，能够很清晰的展示上述关系。</p><p><img src="https://res.mrdear.cn/uPic/image-20210505000759287_1620144479.png" alt="image-20210505000759287"></p><h3 id="读写流程"><a href="#读写流程" class="headerlink" title="读写流程"></a>读写流程</h3><p>先不考虑操作系统的影响，当主控接收到读写命令后，会将其下发到对应的LUN，LUN再下发到Plane上。正常情况下读写流程只需要Cache Register参与即可。举个例子，写入时，数据先写到Cache Register，然后再由Cache Register写入到闪存介质中，读取时，数据先读取到Cache Register，然后再传输到主控，这里的读写单位都是Page。</p><p>那么Page Register有什么用？闪存除了上述正常读写流程外，还支持Cache读写，在Cache读情况下，当主控读取Cache Register时，Page Register可以开始读取下一份数据，也就是预读，从而减少等待时间。同理，Cache写情况下当一份数据正在写入时，主控可以将另一份数据传输到Cache Register中。这里博主是类比计算机设计，一个SSD看作是小型计算机系统，主控作为CPU属于高速设备，存储介质自然是低速设备，两者之间速度不匹配带来了巨大的CPU性能损耗，因此Cache Register以及Page Register承担的是寄存器的作用，尽可能降低这种速度不匹配带来的影响。</p><p><img src="https://res.mrdear.cn/uPic/image-20210505102331283_1620181411.png" alt="image-20210505102331283"></p><h3 id="Block有什么用"><a href="#Block有什么用" class="headerlink" title="Block有什么用"></a>Block有什么用</h3><p>上述读写流程中，并没有出现Block这一结构，那么为什么需要Block？</p><p>在SSD中，由于NAND Flash的特性，每次写入都是以Page维度，并且只能写入到空闲的Page，无法覆写原本有内容的Page，因此产生了擦除。由于擦除本身需要高电压，让电子转移，也因此Block的存在是为了应对数据擦除，对于SSD来说数据的擦除是在对应存储单元上加高电压，经过足够长的时间后，电子会丢失，整个存储单元回到初始状态。</p><h2 id="SSD核心：FTL"><a href="#SSD核心：FTL" class="headerlink" title="SSD核心：FTL"></a>SSD核心：FTL</h2><p>可以认为Block是SSD的基本管理单位，由于闪存块的寿命限制，整个Block的管理算法并没有想象中那么简单，常见的有以下几个问题：</p><ul><li>由于Page不能覆写，当数据发生变更时，必须写入到一个新的位置，那么必须需要映射表存在。旧位置的数据此时成为了垃圾数据，那么必须需要GC来进行垃圾回收。</li><li>闪存块都是有具体寿命的，因此要保证SSD的整体寿命以及性能，需要均衡每个闪存块的擦除次数，保证整体使用寿命，这叫磨损平衡。</li><li>闪存块读取存在次数限制，读的太多了，上面数据会出错，造成读干扰，因此在读取一定次数后，需要将数据搬迁到新的块当中。同样，如果长时间不读，那么电子也会流失，造成数据错乱，闪存块也需要搬动数据来提高数据准确性。这也是SSD断电不使用容易丢失数据的本质原因。</li></ul><p>上述问题的解决全靠FTL (Flash Translation Layer)，FTL最基础的功能是将主机的逻辑地址空间翻译成闪存的物理地址空间，除此之外好的FTL还会实现上述的垃圾回收，磨损平衡，坏块管理，数据保持等问题。</p><h3 id="页映射"><a href="#页映射" class="headerlink" title="页映射"></a>页映射</h3><p>操作系统访问SSD时，是通过LBA(Logical Block Address)进行寻址，LBA的大小由具体的文件系统所决定，一般为4KB。SSD内部维护了一个逻辑页到物理页的映射关系表，用户每写入一个逻辑页，就会产生一条新的映射关系。</p><p>SSD会在内部开辟一个单独的空间用于存储映射表，以256G大小的SSD，映射表大概256MB，SSD板载的DRAM其主要目地是为了缓存该映射表，这样，映射关系的查找就会变得非常迅速，从而提高整个SSD的访问效率。</p><p><img src="https://res.mrdear.cn/uPic/image-20210505114449143_1620186289.png" alt="image-20210505114449143"></p><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>由于闪存无法覆盖写，那么数据变更时，变更部分会直接写入到新的区域。FTL会控制一个块上垃圾页的比例，垃圾页大于一定阈值时，触发垃圾回收，主要流程是将正常页搬迁到其他块，然后对整个块进行擦除达到回收目地。如下图所示，回收到x,y两个块的可用数据迁移到z，同时擦除x，y。</p><p><img src="https://res.mrdear.cn/uPic/image-20210505140231494_1620194551.png" alt="image-20210505140231494"></p><p>这里额外提下Trim指令，Trim是SSD提供的指令，用于主机上删除文件时，主动通知SSD对应文件已经被删除，这样可以方便对SSD做垃圾回收，而不是写入时才垃圾回收。按理来说这个是本来就该有的指令，为什么单独提起呢？我想大概原因还是SSD近些年才开始大范围普及，早起的HDD是支持覆写的，不需要垃圾回收，操作系统给定指令直接写即可，而SSD需要擦除后才能写，因此多了这一步骤。现在的SSD基本都默认开启了trim，我们也无需太关注这个。</p><h3 id="磨损平衡"><a href="#磨损平衡" class="headerlink" title="磨损平衡"></a>磨损平衡</h3><p>每个闪存块的寿命有限，想要保证SSD最佳寿命，即需要保证每个闪存块的擦除数保持平衡。从数据的更新频次来看，主要有冷数据以及热数据，比如操作系统的很多文件，写入后基本不再更新。而日常应用日志却更新频繁。那么FTL需要将冷的数据搬迁到<strong>写入次数</strong>比较多的闪存块，这叫静态磨损平衡。此外FTL还需要将热数据写到磨损次数比较少的块上，这叫动态磨损平衡。</p><h3 id="数据保持"><a href="#数据保持" class="headerlink" title="数据保持"></a>数据保持</h3><p>数据保持主要解决两个问题，其一是读次数限制，读次数主要因为读取时是加一定电压，相当于轻微写入，次数多了自然会造成数据不准确，FTL的做法很简单，针对读大于一定次数的块，主动搬迁数据到新的块，然后擦除该块。其二是电子自然流失导致数据不准确，FTL则会每隔一段时间对块进行扫描，发现其中bit翻转大于一定阈值，则主动进行搬迁刷新数据。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>整个SSD设计还有很多其他的问题需要处理，本文根据书籍内容只是做了一些简单总结，有兴趣的建议看参考中的书籍，写的很详细，值得阅读。</p><p>另外一块单独的SSD我们可以理解是一块未被开垦的荒地，想要实际存储数据还需要搭配文件系统+操作系统，这部分内容后续文章会分析总结，敬请期待。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《深入浅出SSD-固态存储核心技术》- SSDFans</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近开始读《深入浅出SSD-固态存储核心技术》等相关存储原理的书籍，本文是根据书内容所做的总结，解答了博主多年以来对存储方面的疑惑，希望本文对你有帮助。&lt;/p&gt;
&lt;h2 id=&quot;SSD物理结构&quot;&gt;&lt;a href=&quot;#SSD物理结构&quot; class=&quot;headerlink&quot; t</summary>
      
    
    
    
    <category term="操作系统" scheme="https://mrdear.cn/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="读书笔记" scheme="https://mrdear.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>造轮子--Command Search Alfred</title>
    <link href="https://mrdear.cn/posts/tools-alfred-cmd-search.html"/>
    <id>https://mrdear.cn/posts/tools-alfred-cmd-search.html</id>
    <published>2021-02-22T14:35:58.000Z</published>
    <updated>2021-02-22T14:36:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>这个插件自己已经用了将近两年了，现在日常工作中完全离不开该插件了，最近更新版本才发现之前没好好写过文章宣传一波，特此补上。</p><h2 id="问题场景"><a href="#问题场景" class="headerlink" title="问题场景"></a>问题场景</h2><p>先说说解决的场景是什么？</p><p>入职新公司后，第一件事情要做的就是熟悉环境，熟悉各种平台，要记住非常多的地址，这个时候大部分人会选择使用收藏夹，但问题是找起来麻烦，而且遇到一个平台分成DEV,TEST,PRE,PROD四个环境时，收藏夹中会出现大量冗余，带来搜索不便，该插件就是解决这个问题场景。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>该workflow把命令分为key -&gt; values形式,如下所示,key属于大分类,匹配到key后会显示其下全部value.</p><p>目前支持yaml格式(推荐)以及json配置，这里以yaml为例介绍字段含义</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">key:</span> <span class="string">用于搜索指令</span></span><br><span class="line">  <span class="attr">remark:</span> <span class="string">用于指令描述</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">辅助搜索关键词，可以不填写</span></span><br><span class="line">  <span class="attr">values:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">cmd:</span> <span class="string">搜索命中后展示的内容</span></span><br><span class="line">      <span class="attr">remark:</span> <span class="string">命中后内容描述</span></span><br></pre></td></tr></table></figure><p><strong>eg：yaml格式</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">key:</span> <span class="string">ss</span></span><br><span class="line">  <span class="attr">remark:</span> <span class="string">搜索引擎</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">sousuo,baidu,duoji</span></span><br><span class="line">  <span class="attr">values:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">cmd:</span> <span class="string">https://www.baidu.com/s?wd=&#123;clip_0&#125;</span></span><br><span class="line">      <span class="attr">remark:</span> <span class="string">百度地址</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">cmd:</span> <span class="string">https://www.dogedoge.com/results?q=&#123;clip_0&#125;</span></span><br><span class="line">      <span class="attr">remark:</span> <span class="string">多吉搜索</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">key:</span> <span class="string">cc</span></span><br><span class="line">  <span class="attr">remark:</span> <span class="string">通用命令</span></span><br><span class="line">  <span class="attr">values:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">cmd:</span> <span class="string">git</span> <span class="string">branch</span> <span class="string">-r</span> <span class="string">|</span> <span class="string">sed</span> <span class="string">&#x27;s/origin///g&#x27;</span> <span class="string">|</span> <span class="string">grep</span> <span class="string">&#x27;/&#x27;</span> <span class="string">|</span> <span class="string">xargs</span> <span class="string">git</span> <span class="string">push</span> <span class="string">origin</span> <span class="string">--delete</span></span><br><span class="line">      <span class="attr">remark:</span> <span class="string">git批量删除远程分支&#125;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">cmd:</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">--registry=http://registry.npm.alibaba-inc.com</span> &#123;<span class="string">clip_0</span>&#125;</span><br><span class="line">      <span class="attr">remark:</span> <span class="string">npm使用淘宝源安装</span></span><br></pre></td></tr></table></figure><p><strong>eg：json格式</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;搜索引擎&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;values&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;cmd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://www.baidu.com/s?wd=&#123;clip_0&#125;&quot;</span><span class="punctuation">,</span> </span><br><span class="line">        <span class="attr">&quot;remark&quot;</span><span class="punctuation">:</span> <span class="string">&quot;百度地址&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;remark&quot;</span><span class="punctuation">:</span> <span class="string">&quot;搜索引擎&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;git-common&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;values&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;cmd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;git branch -r | sed &#x27;s/origin///g&#x27; | grep &#x27;/&#x27; | xargs git push origin --delete&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;remark&quot;</span><span class="punctuation">:</span> <span class="string">&quot;git批量删除远程分支&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;remark&quot;</span><span class="punctuation">:</span> <span class="string">&quot;git通用命令&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>主要功能:</p><ol><li>cmd(触发关键词)-&gt;搜索key-&gt;选择value-&gt;复制到粘贴板(可以自动粘贴)</li><li>cmd(触发关键词)-&gt;搜索key-&gt;选择value-&gt; 判断是网址 -&gt; 调用浏览器打开</li><li>cmd(触发关键词)-&gt;open-&gt;选择打开命令配置-&gt;调用你喜欢的编辑器打开命令配置(需要在workflow中配置打开应用,默认是TextEdit)</li></ol><p>支持获取粘贴板，使<code>&#123;clip_0&#125;</code>来代替，最终渲染时会自动进行粘贴板数据替换。比如我选择了<code>https://www.baidu.com/s?wd=&#123;clip_0&#125;</code>，此时我粘贴板数据假设为 <code>张三</code>，那么最终打开浏览器的地址为<code>https://www.baidu.com/s?wd=张三</code>。</p><h2 id="数据保存"><a href="#数据保存" class="headerlink" title="数据保存"></a>数据保存</h2><p>该插件对应命令数据支持外置的(便于云端保存,丢到同步盘中即可),因此自己指定一个路径后,以参数形式传入即可.</p><p><img src="https://res.mrdear.cn/uPic/PJgMxW_1614003592.png"></p><h2 id="更多变量支持"><a href="#更多变量支持" class="headerlink" title="更多变量支持"></a>更多变量支持</h2><p>变量的支持依赖于alfred，可以在自己的脚本中配置多个变量，在后面使用<code>Utils</code>工具替换。</p><p><img src="http://res.mrdear.cn/1539613678.png"></p><h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><p><img src="https://res.mrdear.cn/uPic/yulan_1614005703.gif"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这个插件自己已经用了将近两年了，现在日常工作中完全离不开该插件了，最近更新版本才发现之前没好好写过文章宣传一波，特此补上。&lt;/p&gt;
&lt;h2 id=&quot;问题场景&quot;&gt;&lt;a href=&quot;#问题场景&quot; class=&quot;headerlink&quot; title=&quot;问题场景&quot;&gt;&lt;/a&gt;问题场景&lt;</summary>
      
    
    
    
    <category term="工具" scheme="https://mrdear.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="轮子" scheme="https://mrdear.cn/tags/%E8%BD%AE%E5%AD%90/"/>
    
    <category term="Alfred" scheme="https://mrdear.cn/tags/Alfred/"/>
    
  </entry>
  
  <entry>
    <title>Java -- 线程池使用不当引发的死锁</title>
    <link href="https://mrdear.cn/posts/java_threadpool_completablefuture.html"/>
    <id>https://mrdear.cn/posts/java_threadpool_completablefuture.html</id>
    <published>2021-02-20T14:54:00.000Z</published>
    <updated>2021-02-20T14:54:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间线上写了一个DAG调度框架，整个DAG依赖关系以及执行依赖JDK8提供的CompletableFuture，运行一段时间后，生产出现了业务死锁问题，经过一番排查后，发现是使用不当造成，遂记录该篇文章希望对你有帮助。</p><h2 id="问题场景回顾"><a href="#问题场景回顾" class="headerlink" title="问题场景回顾"></a>问题场景回顾</h2><p>主要业务是发起DAG图的执行，如下图所示，用户发起一个DAG任务请求，该请求到达Planner后，异步去启动一个DAG任务，当执行到DAG时，该DAG会异步遍历整个图，然后阻塞的获取最后结果。</p><p><img src="http://res.mrdear.cn/uPic/image-20210217160324691_1613832332.png-default" alt="image-20210217160324691"></p><p>原有业务系统太过于复杂，因此我将相关逻辑提取了出来，简述为以下代码表示，其中关键链路如下：</p><ul><li>用户对一个同步操作发起异步调用</li><li>该同步操作本质上是异步调用，同步等待</li><li>两者使用了同一个线程池</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">30L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">20</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">          <span class="comment">// 模拟用户想要异步执行一个任务</span></span><br><span class="line">            CompletableFuture.supplyAsync(Test::work, executor);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 检查状态，会发现queue一段时间后，一直稳定在一个值，即线程池不再执行新任务</span></span><br><span class="line">        <span class="keyword">while</span> (executor.getQueue().size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;executor queue=%s%n&quot;</span>, executor.getQueue().size());</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 模拟一个异步调用，但同步返回的任务</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">work</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> CompletableFuture.supplyAsync(Test::workInnerTask, executor).get();</span><br><span class="line">            System.err.println(String.format(<span class="string">&quot;%s thread result=%s&quot;</span>, Thread.currentThread().getName(), result));</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">workInnerTask</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ThreadLocalRandom.current().nextInt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>该代码在运行一段时间后，发生了死锁，具体现象为：ThreadPool中queue在不停的累计，但所有的core thread全部处于WAITING状态。也就是说线程池中的每一个线程都在等待某一个信号，从而导致queue中的任务无法消费。</p><p><img src="http://res.mrdear.cn/uPic/image-20210220171444574_1613832332.png-default" alt="image-20210220171444574"></p><h2 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h2><p>从现象来看，问题的原因是线程池中core线程执行的任务被阻塞了，一直无法完成，所以新的任务不停的往queue中累积。那为什么线程池中的core线程会被阻塞？</p><p>首先找出与线程池相关的代码，确定线程池中执行了哪些任务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程池执行了Test::work这个任务</span></span><br><span class="line">CompletableFuture.supplyAsync(Test::work, executor);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池执行了Test::workInnerTask这个任务</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> CompletableFuture.supplyAsync(Test::workInnerTask, executor).get();</span><br></pre></td></tr></table></figure><p>比较特殊的是 <strong>Test::work</strong> 这个任务的完成依赖于<strong>Test::workInnerTask</strong>，那么需要<strong>Test::workInnerTask</strong>执行完毕<strong>Test::work</strong>才能完成，然而线程池是先将<strong>Test::work</strong>放入到queue，再将<strong>Test::workInnerTask</strong>放入到queue，那么只要前者足够多到将core线程池全部占满，就会导致后者一直无法完成，前者由于等待后者也无法完成，造成死锁。</p><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>原因定位到后，解决思路就很清晰了。</p><p>第一种方式，将<strong>Test::work</strong>放入到另一个独立的线程池中执行。两边线程池互不影响，那么在一个queue上就不会产生阻塞。</p><p>第二种方式，去除<strong>Test::work</strong>中的get()阻塞，让其返回CompletableFuture，也就是异步调用就全链路执行异步，没必要中间出现同步代码。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个简化版案例代码，可以很容易找到具体原因，但是在复杂业务系统中，调用链路错综复杂，由于线程池的复用很容易引发类似问题，如何才能避免这种问题呢？</p><p>博主想了许久，没有找到靠谱的结论，不过有两点准则在日常开发中可以参考：</p><p>1.业务系统尽量不要使用公共线程池，不同的业务使用不同的线程池隔离</p><p>2.阻塞操作想要变异步时，使用单独线程池，而不是公共线程池</p><p>如果您有更好的建议，欢迎分享。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前段时间线上写了一个DAG调度框架，整个DAG依赖关系以及执行依赖JDK8提供的CompletableFuture，运行一段时间后，生产出现了业务死锁问题，经过一番排查后，发现是使用不当造成，遂记录该篇文章希望对你有帮助。&lt;/p&gt;
&lt;h2 id=&quot;问题场景回顾&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="夯实Java基础" scheme="https://mrdear.cn/categories/%E5%A4%AF%E5%AE%9EJava%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java" scheme="https://mrdear.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Netty -- 粘包与半包详解</title>
    <link href="https://mrdear.cn/posts/framework-netty-half-packet.html"/>
    <id>https://mrdear.cn/posts/framework-netty-half-packet.html</id>
    <published>2020-12-19T05:47:51.000Z</published>
    <updated>2020-12-19T05:47:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>粘包与半包在中文网络上争议很大，有些人认为这是中式伪概念，对于一个流式协议来说本身没有包概念，何来粘包与半包说法，这种说法是对流式协议理解不到位才会导致这样的翻译，博主认为这样理解也没多大问题，粘包与半包是应用层出现的问题，但不能只揪住这一点，因为该问题确确实实存在，分析清楚然后解决它才是目地。博主希望大家理性看待，少一些争论。</p><h2 id="什么是粘包和半包"><a href="#什么是粘包和半包" class="headerlink" title="什么是粘包和半包"></a>什么是粘包和半包</h2><p>粘包与半包是应用层协议在对接TCP&#x2F;IP网络协议时，对所遇到的对接问题定义的概念，所以在使用Netty编写网络通信框架时，这一概念经常被提起。那么什么是粘包和半包问题呢？</p><p>在网络编程中，客户端往服务端发送消息是以消息为单位，TCP&#x2F;IP传输时，消息会被拆分为多个数据包，该层是以数据包为单位，接着三次握手之后，服务端通过accept()函数获取到该连接，然后开始读取数据，读取的是一个个数据包，此时客户端的消息相当于失真，需要服务端将这些数据包还原成对应的消息，在还原过程中就可能出现如下情况：</p><p>在Time1时刻，服务端只拿到了数据包1，此时并不能完整的还原出消息A，这种现象被称为<strong>半包</strong>，对于服务端的影响是需要判断一个包是否完整，从而才能决定是否反序列化成应用层消息体。</p><p>在Time2时刻，服务端又拿到了数据包2，但数据包2中除了消息A还有消息B的部分内容，这种现象称为<strong>粘包</strong>，对服务端的影响是需要感知消息A的结束，以及消息B的起始位置。</p><p>本文接下来会从整个链路角度，来详细解释产生这种问题的本质原因，以及介绍一些经典应用层协议的优秀解法。</p><p><img src="http://res.mrdear.cn/uPic/image-20201212143540829_1607754940.png-default" alt="image-20201212143540829"></p><h2 id="TCP-IP协议为什么会粘包-半包？"><a href="#TCP-IP协议为什么会粘包-半包？" class="headerlink" title="TCP&#x2F;IP协议为什么会粘包&#x2F;半包？"></a>TCP&#x2F;IP协议为什么会粘包&#x2F;半包？</h2><p>粘包&#x2F;半包现象与TCP关联最多，要详细了解产生这类问题的本质原因，需要对整个链路传输情况有个大致的了解，关键点是每个阶段其认为的消息传输最小单位是什么，这个最小单位决定了该层对消息将如何拆分。</p><h3 id="应用层传输"><a href="#应用层传输" class="headerlink" title="应用层传输"></a>应用层传输</h3><p>应用层是面向业务的一层，以浏览器访问百度为例，会发送如下HTTP协议完整消息，包含起始行，头部，空行(CRLF)，实体(payload)，那么完整的HTTP协议请求格式是该层认为的最小传输单位。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">curl &#x27;https://www.baidu.com/&#x27; \</span><br><span class="line">  -H &#x27;Connection: keep-alive&#x27; \</span><br><span class="line">  -H &#x27;Pragma: no-cache&#x27; \</span><br><span class="line">  -H &#x27;Cache-Control: no-cache&#x27; \</span><br><span class="line">  -H &#x27;Upgrade-Insecure-Requests: 1&#x27; \</span><br><span class="line">  -H &#x27;User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 11_0_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.67 Safari/537.36 Edg/87.0.664.55&#x27; \</span><br><span class="line">  -H &#x27;Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&#x27; \</span><br><span class="line">  -H &#x27;Sec-Fetch-Site: cross-site&#x27; \</span><br><span class="line">  -H &#x27;Sec-Fetch-Mode: navigate&#x27; \</span><br><span class="line">  -H &#x27;Sec-Fetch-User: ?1&#x27; \</span><br><span class="line">  -H &#x27;Sec-Fetch-Dest: document&#x27; \</span><br><span class="line">  -H &#x27;Referer: https://www.dogedoge.com/&#x27; \</span><br><span class="line">  -H &#x27;Accept-Language: zh-Hans-CN,zh-CN;q=0.9,zh;q=0.8,en;q=0.7,en-GB;q=0.6,en-US;q=0.5,zh-TW;q=0.4,pl;q=0.3,ja;q=0.2&#x27; \</span><br><span class="line">  -H &#x27;Cookie: xxxxxxxxxxx&#x27; \</span><br><span class="line">  --compressed</span><br></pre></td></tr></table></figure><p><img src="http://res.mrdear.cn/uPic/image-20201213102222625_1607826142.png-default" alt="image-20201213102222625"></p><h3 id="TCP层传输"><a href="#TCP层传输" class="headerlink" title="TCP层传输"></a>TCP层传输</h3><p>应用层到达TCP层后，TCP并不关心对应的业务，在TCP看来要发送的数据就是一定长度的二进制序列而已。数据提交过来时，会先进入到一个发送缓冲区，而不是立马发送，因为TCP不知道应用层是一次性写入还是分多段写入。那么TCP什么时候开始发送呢？</p><p>TCP会根据MSS大小进行判断，MSS到底多大，受限于MTU，MTU表示一个网络包的最大长度，是数据链路层的限制，在网卡处可以设置，路由器处也可以设置，一般为1500字节，MSS是一般为1460 (MTU(1500) - IP头部(20) - TCP头部(20))。</p><p><img src="http://res.mrdear.cn/uPic/image-20201213095903320_1607824743.png-default" alt="image-20201213095903320"></p><p>在三次握手时，通讯双方为了最大效率会协商MSS大小，确定最优MSS，一般是最小的一个值，就像木桶效应一样，盛水量取决于最短的一块木板。当TCP收到的数据长度超过或者接近MSS时，再发送数据，避免大量小包问题，从而提高网络效率。</p><p>正是因为这样，所以应用层的消息到TCP层后，如下图所示会拆分成多个数据段，每个数据段长度小于或者等于MSS，数据块 + TCP头部，组成了TCP层的数据段，因此数据段是TCP层数据传输的最小单位。</p><p><img src="http://res.mrdear.cn/uPic/image-20201213104229881_1607827349.png-default" alt="image-20201213104229881"></p><h3 id="IP层传输"><a href="#IP层传输" class="headerlink" title="IP层传输"></a>IP层传输</h3><p>IP层主要与数据链路层打交道，也就是路由器的端口，由于路由器的端口对接不同线路，每个线路最大传输包长度不尽相同，遇到这种情况需要IP层的定义的分片功能对较大的数据段进行拆分。</p><p>分片的过程首先是获取MTU，也就是最大网络包长度限制，MTU一般是物理端口支持最大包长度(1518) - MAC头部(14) - 尾部校验+FCS(4) &#x3D; 1500，知道MTU后，拆包就按照MTU长度拆即可，拆出来的小包不需要有TCP头了，直接附属上IP头即可，如下图所示，数据块1被拆分为数据包1.1和数据包1.2，其中1.2部分只需要IP头部即可，因此数据包是IP层的最小传输单位。</p><p><img src="http://res.mrdear.cn/uPic/image-20201213104242456_1607827362.png-default" alt="image-20201213104242456"></p><h3 id="粘包原因以及长连接短连接"><a href="#粘包原因以及长连接短连接" class="headerlink" title="粘包原因以及长连接短连接"></a>粘包原因以及长连接短连接</h3><p>经过上面的分析，应用层一个请求传输过程中，会被两次拆分，其中第一次TCP拆分时，通过MSS参数尽量避免IP层而二次拆分，即使IP层数据拆分后，在服务端IP层也会将数据合并起来，完整的将数据段交给TCP层，然后转交给应用层，那么粘包与半包自然而然就是TCP分段传输带来的问题了。</p><p>具体分析半包，半包是由于应用层数据太大，到TCP层后会被分段传输，到达服务端，应用层看到的是一段一段的数据，此时需要服务端等待全部数据到达后，才能还原出具体的应用层消息，也因此无论长连接还是短连接，都会出现半包问题。</p><p>具体分析粘包，粘包的发生是因为应用层使用同一个TCP连接传输了消息A和消息B，也就是长连接情况下会发生的问题，长连接下，TCP通道会被复用，顺序传输多次请求，由于TCP发送缓存队列存在，就会导致两个请求在一个数据段中。短链接情况下，每一次建立连接只会传输一个请求，传输完毕就关闭连接，这种情况下自然不存在粘包现象。</p><h2 id="UDP-IP为什么不会粘包？"><a href="#UDP-IP为什么不会粘包？" class="headerlink" title="UDP&#x2F;IP为什么不会粘包？"></a>UDP&#x2F;IP为什么不会粘包？</h2><p>UDP是仅仅是为了传输开发的协议，UDP在接收到应用层消息体后，是直接将全部消息体丢给IP层，依赖IP层的分片，自身传输仍然是以消息为单位，那么服务端接收到的自然也是IP层重组合并之后的消息，因此不会出现粘包以及半包现象。</p><p><img src="http://res.mrdear.cn/uPic/image-20201213123059614_1607833859.png-default" alt="image-20201213123059614"></p><h2 id="粘包与半包常见解决方案"><a href="#粘包与半包常见解决方案" class="headerlink" title="粘包与半包常见解决方案"></a>粘包与半包常见解决方案</h2><p>TCP只是在保证可靠性的前提下，尽可能提高网络利用率，粘包与半包是应用层需要解决的问题，解决方案的主要思路是增加消息边界描述，应用层在解析时能够感知到消息边界，具体做法则有很多黑科技可以讨论了，接下来分析下一些主流协议使用的解决方案。</p><h3 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP&#x2F;1.1"></a>HTTP&#x2F;1.1</h3><p>HTTP&#x2F;1.1目前仍然在广泛使用，在HTTP&#x2F;1.1当中，开启keep-alive后，TCP连接会被复用，也就是长连接，此时粘包和半包问题都会出现，为了解决类似问题，HTTP对于消息格式有一个强制性要求，借用极客时间的图，第一行是请求行，三个字段使用空格分割，以CRLF结尾，中间部分是请求头，以：号分割，CRLF结尾，以单独一个空行CRLF标识请求头结束，接着是请求体内容。</p><p><img src="http://res.mrdear.cn/uPic/image-20201213142451806_1607840691.png-default" alt="image-20201213142451806"></p><p>服务端解析时，针对请求行和请求头则逐个字节扫描，当发现是LF标识结尾时，即可解析已读取内容，当检测到CRLF之后又一个CRLF则标识请求头解析完毕，接着解析请求体。请求体解析有两种形式，第一种是已知请求体长度，在表单请求中比较常见，其会在Header中声明Content-Length，服务端根据该字段确定接下来再读取多少个字节作为请求体。第二种是不知道请求体长度，比如文件上传，HTTP提供了<code>Transfer-Encoding: chunked</code>这一header标识，开启之后，HTTP会分块传输数据，每一块大小是指定的，终止块是一个长度为0的块。有了这些标准，在粘包以及半包情况下，服务端就知道是该拆分还是该等待。</p><p>举个实际案例，在Netty的<code>io.netty.handler.codec.http.HttpObjectDecoder</code>中，Netty定义了一套状态机流转方式来解析HTTP消息，博主画了一个图，基本模式就是先读取请求行，然后解析请求头，在解析请求头的过程中，判断接下来状态是读取payload还是直接结束，其中黄色框的读取完后，会重置状态，解析下一个HTTP消息，有兴趣的可以翻阅相关源代码查阅。</p><p><img src="http://res.mrdear.cn/uPic/image-20201219104653989_1608346014.png-default" alt="image-20201219104653989"></p><p>简单总结一下，本质上还是使用那个CRLF这一特殊标识定义了消息在各种状态的结束符号，服务端在解析流程中，根据结束符号进行状态流转。</p><h3 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP&#x2F;2.0"></a>HTTP&#x2F;2.0</h3><p>HTTP&#x2F;2.0相比1.1版本，增加了HTTP连接的多路复用，怎么理解呢？在HTTP1.1时期，虽然有<code>keep-alive</code>机制的长连接，但浏览器在获取一个资源时，会独占一个HTTP请求，只有当该资源获取完毕后，该HTTP才能给其他的资源获取使用。但是HTTP2.0时代，<strong>一个HTTP请求可以同时获取多个资源</strong>，HTTP层面资源不再排队等待，极大的提升了网络利用率。在这种模式下，HTTP协议是怎么解决粘包和半包问题的呢？</p><p>在HTTP2中为了支持多路复用，引入了Stream Frame这一结构，当多个HTTP请求使用同一个连接时，HTTP2会给每一个请求分配一个ID，然后将请求数据包装成一个个Stream Frame，丢给TCP连接传输。对于服务端，同一个HTTP请求的数据还是顺序传输的，当接收到一个Stream Frame后，根据头部的Length判断该包的大小，当读取结束时，开始进行整个包的解析。</p><p><img src="http://res.mrdear.cn/uPic/image-20201219115329530_1608350009.png-default" alt="image-20201219115329530"></p><p>那么还有个问题，怎么判断一个HTTP请求数据发送完毕了呢？该问题分为两部分，一是解析Header结束，二是整个请求结束，针对这种情况，Stream Frame的flag属性针对Header结束定义了<strong>END_HEADERS</strong>标识，针对整个流则特别定义了一个<strong>END_STREAM</strong>，因此服务端根据flag标识，能够确定下一步是该读取payload还是结束数据解析。</p><p>也简单总结下，因为是定长结构，处理简单了许多，当半包出现时，等就好了，当粘包出现时，因为长度存在也不会导致读错包，服务端接收到多个Stream Frame后，按照id将对应请求的数据进行合并，当接收到结束帧时，完成整个HTTP请求解析，应用链路可以继续往下调用进行。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>实际上只要基于TCP&#x2F;IP实现应用层协议，不可避免的都会遇到应用层数据被拆分现象，粘包与半包的概念提出是为了解决这个问题，让人比较容易理解，我倒是觉得这两个词相当形象得描绘了这一问题，没必要过度反感与抵制。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;粘包与半包在中文网络上争议很大，有些人认为这是中式伪概念，对于一个流式协议来说本身没有包概念，何来粘包与半包说法，这种说法是对流式协议理解不到位才会导致这样的翻译，博主认为这样理解也没多大问题，粘包与半包是应用层出现的问题，但不能只揪住这一点，因为该问题确确实实存在，分析清</summary>
      
    
    
    
    <category term="框架与中间件" scheme="https://mrdear.cn/categories/%E6%A1%86%E6%9E%B6%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="Netty" scheme="https://mrdear.cn/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>Java -- ThreadLocal问题分析</title>
    <link href="https://mrdear.cn/posts/java_threadlocal.html"/>
    <id>https://mrdear.cn/posts/java_threadlocal.html</id>
    <published>2020-11-27T16:02:46.000Z</published>
    <updated>2020-11-27T16:02:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>关于ThreadLocal内存泄漏的问题，网上有很多讨论，比较一致认同的方案是每次使用完ThreadLocal对象后，调用remove方法释放掉该对象，用来防止内存泄漏。乍一听感觉挺有道理，然而使用ThreadLocal除了解决线程不安全问题之外，其另一个目地是复用对象，如果每次都remove，则只应该在线程入口以及出口操作，而不是在任意调用处操作，不然则失去对象复用的意义。然而没有更好的方式了吗？ThreadLocal这种优秀的理念就这么憋屈的使用？本文将探讨下这些，并希望总结出一套合理的ThreadLocal使用方式。</p><h2 id="问题一：内存泄漏"><a href="#问题一：内存泄漏" class="headerlink" title="问题一：内存泄漏"></a>问题一：内存泄漏</h2><h3 id="为什么会内存泄漏"><a href="#为什么会内存泄漏" class="headerlink" title="为什么会内存泄漏"></a>为什么会内存泄漏</h3><p>在讨论之前，需要了解下Java中<code>WeakReference</code>作用，感兴趣的可以参考<a href="https://mrdear.cn/posts/java_reference.html">Java中的四种引用</a>。简单点来说在GC工作时，如果<code>WeakReference</code>对象没有被强引用所关联，那么就会被GC回收，这个回收是ThreadLocal泄漏原因的根源。<br>ThreadLocal主要实现依赖<code>ThreadLocalMap</code>类，该类使用开放地址法解决hash冲突，当put数据时，<code>ThreadLocalMap</code>会将对应的数据封装为<code>java.lang.ThreadLocal.ThreadLocalMap.Entry</code>对象，填充hash槽，该对象是一个<code>WeakReference</code>子类，被跟踪对象则是ThreadLocal本身，如下图所示，其中<code>ThreadLocal</code>标红代表被弱引用所跟踪。</p><p><img src="http://res.mrdear.cn/1588561192.png"></p><p><strong>清单一：Entry对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">       <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">       Object value;</span><br><span class="line"></span><br><span class="line">       Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">           <span class="built_in">super</span>(k);</span><br><span class="line">           value = v;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>当对应的Entry中ThreadLocal被回收后，Entry中value又是强引用，导致此时Entry无法被释放，就会出现内存泄漏，如下图所示。此时Entry对象永远无法被访问到，也无法被回收，但仍然占用着内存。本质问题是生命周期短的对象引用了生命周期长的对象，导致自身无法释放。<br><img src="http://res.mrdear.cn/1588561933.png"></p><h3 id="什么情况下泄漏"><a href="#什么情况下泄漏" class="headerlink" title="什么情况下泄漏"></a>什么情况下泄漏</h3><p>以下内容只考虑日常开发中使用习惯，不过多考虑极端情况。</p><p>泄漏的本质是弱引用被回收，换句话说不让弱引用被回收即可以解决泄漏，这也是日常开发下建议ThreadLocal对象声明为<code>static final</code>全局变量的好处，当这样声明后，关系图如下所示，此时ThreadLocal由于存在强引用，除非对应的ClassLoader被回收，否则不会被GC回收。<br><img src="http://res.mrdear.cn/1588578060.png"></p><p>那么声明为<code>static final</code>可以高枕无忧吗？当然不行，此时虽然不会因为弱引用问题导致内存泄漏，但是会出现一些线程池中线程分配了部分ThreadLocal对象，但却一直没有使用该对象，那么这些分配未使用过的对象则无法回收，一直处于占坑状态，需要等线程生命周期结束后才能释放，这种也算一种内存泄漏。这种没有比较好的解决方案，常见的是调整线程生命周期，避免线程持续时间太长，二是养成开发意识，在对应行为处使用ThreadLocal需要回收对应内存，对于大部分业务中ThreadLocal的使用来说，所幸的是一般不会造成大问题，顶多是耗费多一点内存。</p><p>再者就是合并部署下可能出现内存泄漏，比如Tomcat服务器可以部署多个web应用，这些web应用是共用一套Tomcat的线程池服务，这种情况比较复杂，比如ThreadLocal中引用了webA的类，webA服务下线时，由于强引用存在，导致ClassLoader无法被回收，此时可能造成内存泄漏。在JDK7时代，Tomcat热部署机制就很容易造成 OOM。如今大多数项目都使用Spring Boot单体部署方式，这种内存泄漏越来越少了。</p><h3 id="ThreadLocal怎么解决泄漏"><a href="#ThreadLocal怎么解决泄漏" class="headerlink" title="ThreadLocal怎么解决泄漏"></a>ThreadLocal怎么解决泄漏</h3><p>由于Entry对key是弱引用，当key也就是ThreadLocal本身被回收后，无法通过key访问该hash槽，造成内存泄漏。ThreadLocalMap在<code>java.lang.ThreadLocal.ThreadLocalMap#expungeStaleEntry</code>方法中实现类对该类数据的回收，该方法遍历对应的hash槽，当发现key为null的数据后，回收对应的槽，如清单二所示，然后ThreadLocalMap类在get以及remove等方法中直接或者间接调用了<code>expungeStaleEntry</code>，因此当出现内存泄漏后，大多数情况能够主动回收该部分泄漏内存。</p><p><strong>清单二：ThreadLocal回收key</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">expungeStaleEntry</span><span class="params">(<span class="type">int</span> staleSlot)</span> &#123;</span><br><span class="line">        Entry[] tab = table;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 回收当前槽</span></span><br><span class="line">        tab[staleSlot].value = <span class="literal">null</span>;</span><br><span class="line">        tab[staleSlot] = <span class="literal">null</span>;</span><br><span class="line">        size--;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Rehash until we encounter null</span></span><br><span class="line">        Entry e;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="comment">// 遍历,回收key为null的槽</span></span><br><span class="line">        <span class="keyword">for</span> (i = nextIndex(staleSlot, len);(e = tab[i]) != <span class="literal">null</span>;i = nextIndex(i, len)) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">                e.value = <span class="literal">null</span>;</span><br><span class="line">                tab[i] = <span class="literal">null</span>;</span><br><span class="line">                size--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                    tab[i] = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">while</span> (tab[h] != <span class="literal">null</span>)</span><br><span class="line">                        h = nextIndex(h, len);</span><br><span class="line">                    tab[h] = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="问题二：使用上次值"><a href="#问题二：使用上次值" class="headerlink" title="问题二：使用上次值"></a>问题二：使用上次值</h2><p>问题二就比较常见了，使用了ThreadLocal，却没有清理，导致第二次重用了旧数据。这种错误是ThreadLocal犯的最多，且最致命的问题，举个博主之前写过的bug，场景如下：</p><p>后端提供了一个查询系统所拥有数据的API，由于系统拥有很多不同类型数据，不如枚举信息、用户权限信息、系统状态等，数据都分布在不同的表，因此该接口会并发查询，简略示意图如下，后台使用了策略模式，每一种信息的查询是一个单独的策略接口，前端传入要获取的信息类型，后端根据类型进行<code>parallelStream</code>并发获取。</p><p>博主当时想也没想，就直接把用户权限的获取写成了一个策略实现类，踩了坑。本质问题是获取用户信息的<code>RequestUserHolder</code>本质上是从ThreadLocal中获取，而<code>parallelStream</code>底层实现为forkjoin，会根据当前负载情况拆分任务到CommonPool线程池中执行。由于存在线程复用，因此用户信息在请求线程ThreadLocal，调用到parallelStream后，第一次创建CommonPool线程池时，是能够传递ThreadLocal到子线程，之后线程复用，无法传递ThreadLocal，造成数据混乱使用。</p><p><img src="http://res.mrdear.cn/uPic/image-20201127232939603_1606492904.png-default" alt="image-20201127232939603"></p><h2 id="如何更好的使用ThreadLocal？"><a href="#如何更好的使用ThreadLocal？" class="headerlink" title="如何更好的使用ThreadLocal？"></a>如何更好的使用ThreadLocal？</h2><p>讲了那么多，根据上述缺陷，博主总结了以下使用点：</p><ul><li>使用static final进行修饰，避免因为弱引用回收带来的内存泄漏</li><li>优先使用ThreadLocal对JDK自带的类进行引用，避免多应用部署时，阻塞ClassLoader回收</li><li>对于业务类型的对象，比如用户信息，使用完成后一定要主动清理</li><li>对于容器性质的对象，包装一层重置对象后再提供给其他代码访问，如下StringBuilder复用所示</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;StringBuilder&gt; LOCAL = ThreadLocal.withInitial(StringBuilder::<span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> StringBuilder <span class="title function_">getBuilder</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> LOCAL.get();</span><br><span class="line">    <span class="keyword">if</span> (builder.capacity() &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">        builder.setLength(<span class="number">200</span>);</span><br><span class="line">        builder.trimToSize();</span><br><span class="line">    &#125;</span><br><span class="line">    builder.setLength(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> builder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;关于ThreadLocal内存泄漏的问题，网上有很多讨论，比较一致认同的方案是每次使用完ThreadLocal对象后，调用remove方法释放掉该对象，用来防止内存泄漏。乍一听感觉挺有道理，然而使用ThreadLocal除了解决线程不安全问题之外，其另一个目地是复用对象，如</summary>
      
    
    
    
    <category term="夯实Java基础" scheme="https://mrdear.cn/categories/%E5%A4%AF%E5%AE%9EJava%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java" scheme="https://mrdear.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java -- MetaSpace线上问题排查</title>
    <link href="https://mrdear.cn/posts/java_metaspace.html"/>
    <id>https://mrdear.cn/posts/java_metaspace.html</id>
    <published>2020-10-18T02:51:55.000Z</published>
    <updated>2020-10-18T02:51:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近遇到了两起metaspace问题，借此机会对metaspace进行一个回顾梳理，希望能帮到其他人。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>现象一：MetaSpace频繁引起full gc？</p><p>应用A，线上机器运行一段时间后频繁触发full gc，根据监控发现是MetaSpace达到设定的-XX:MaxMetaspaceSize&#x3D;512m，每次full gc后还会占用450M+，之后很快达到512M，再次触发full gc，如此反复。</p><p>现象二：MetaSpace无限增大，最终导致OS kill掉应用</p><p>应用B是一个新申请的应用，运行一段时间后，个别机器内存会被java进程占据90%以上，最终由于内存占用过高，被OS kill掉。</p><p>两者系统的共同点是都用了<a href="https://github.com/killme2008/aviatorscript">https://github.com/killme2008/aviatorscript</a>，以及大量groovy脚本，想必大概原因是出在这里，为了搞清楚上述两个现象背后的原因，需要对MetaSpace的原理有一定了解，博主带着一堆问题开始了google。。。</p><h2 id="MetaSpace的由来"><a href="#MetaSpace的由来" class="headerlink" title="MetaSpace的由来"></a>MetaSpace的由来</h2><p>MetaSpace被称为元数据空间，在JDK8版本中退出代替JDK7的perm(永久代)。关于为什么会替代，说法众说纷纭，博主觉得比较合理的解释是为了解决OOM问题。</p><p>在JDK7时代，不少人经历过<code>Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: PermGen space</code>，比如Tomcat7的热部署，频繁触发的话，很快就导致系统挂掉，究其原因是PermGen利用了堆内存，而生产环境堆内存一般会设置最大值，那么就带来该给PermGen分配多少的问题，分配多了有点浪费，分配少了则频繁Full gc。相比PermGen，MetaSpace最大的变化就是使用直接内存，因此最大占用不受堆内存限定，而取决于操作系统，其次是JDK8下lambdas新增表达式，大量的运用会为该区域带来不确定性。但从上述两个问题来看，该有的问题还是一个都不少。。。</p><h2 id="MetaSpace里面存的是什么"><a href="#MetaSpace里面存的是什么" class="headerlink" title="MetaSpace里面存的是什么"></a>MetaSpace里面存的是什么</h2><p>MetaSpace主要存放class metadata，class metadata可以理解为记录了Java类在JVM中的静态信息，主要包含：</p><ul><li>KLass结构，Class文件在JVM里面运行时的数据结构</li><li>NoKlass<ul><li>method metadata，包括方法的字节码，局部变量表，异常表，参数信息等</li><li>常量池：Class中的符号常量</li><li>注解</li><li>方法计数器：记录方法执行次数，辅助JIT决策</li></ul></li></ul><h2 id="MetaSpace常用参数以及如何扩容"><a href="#MetaSpace常用参数以及如何扩容" class="headerlink" title="MetaSpace常用参数以及如何扩容"></a>MetaSpace常用参数以及如何扩容</h2><p>常用参数主要有以下三个：</p><ul><li><p>MetaSpaceSize</p><p>默认20.8M大小，主要控制metaspaceGC发生的初始阈值，也是最小阈值。</p></li><li><p>MaxMetaSpaceSize</p><p>默认无穷大，一旦到达这个值就会触发full gc，该值设定后，不会在JVM一开始就分配该部分内存，而是随着使用不断申请，直到达到这个值。</p></li><li><p>CompressedClassSpaceSize</p><p>默认1G，设置Klass MetaSpace的大小，该参数生效前提是开启压缩指针，达到该参数大小后也会触发full gc</p></li></ul><p>那么MetaSpace是如何扩容的呢？</p><p>以参数 -XX:MetaspaceSize&#x3D;256m -XX:MaxMetaspaceSize&#x3D;512m为例，当JVM启动时，会经历以下步骤：</p><ol><li>按照JVM需要申请MetaSpaceSize内存，该部分是按需申请</li><li>随着系统运行当MetaSpace不断增加，第一次达到-XX:MetaSpaceSize&#x3D;256m时，触发full gc，这个是初始GC阈值</li><li>第一次GC释放掉一些后，系统随着运行还在不断增加，当达到-XX:MaxMetaspaceSize&#x3D;512m时，再次触发full gc，如此反复</li><li>这其中还有个参数-XX:CompressedClassSpaceSize&#x3D;1G，该参数一般难以达到，当达到后也会触发full gc。</li></ol><p>到这一步，上述问题就很好解释了。</p><h2 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h2><p>无论是aviator还是groovy其都是JVM上的动态语言，动态语言的特点是动态Classloader以及随时随地新建类，那么metaspace内存一直增长就是由这些带来的。博主所在公司提供了JDK的metaspace dump功能，导出后由分析工具也能看到一堆的aviatorClassLoader以及groovyClassLoader，也可以使用<code>jmap -clstats PID</code>定位。</p><p>问题一：问题一设置了XX:MaxMetaSpaceSize&#x3D;512m参数，所以最大值不会突破512M，由于使用了动态脚本引擎，因此会不断的加载新的类以及新建ClassLoader，因此导致MetaSpace不断的达到阈值，触发full gc，解决方案是增加缓存，对相同的表达式不再触发编译操作。</p><p>问题二：问题二由于是一个新应用，配套的JVM参数在走应用上线流程时并没有生效，因此其MetaSpace会不断的增加，直到达到系统最大值，被操作系统kill。解决方案增加上述参数即可。</p><h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p>感谢网友<a href="https://github.com/mrdear/blog-comment/issues/70">Rain-Chen</a>的建议，上述方案虽然也能够解决当前问题，但治标不治本，该业务的表达式随时间变化，而不是一个静态表达式，因此缓存也只能有一段时间效果，从而降低full gc频率，根本的解决方案是替换表达式引擎，这种频繁场景下使用更加轻量级的解决方案，不过这是另一个话题了，本文不多讨论。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>对JVM了解不多，如有错误还请指出。</p><p><a href="http://lovestblog.cn/blog/2016/10/29/metaspace/">JVM源码分析之MetaSpace解密</a></p><p><a href="https://www.javadoop.com/post/metaspace">深入理解堆外内存 MetaSpace</a></p><p><a href="https://www.jianshu.com/p/b448c21d2e71">JVM参数MetaSpaceSize的误解</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近遇到了两起metaspace问题，借此机会对metaspace进行一个回顾梳理，希望能帮到其他人。&lt;/p&gt;
&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;现象一：MetaSpa</summary>
      
    
    
    
    <category term="夯实Java基础" scheme="https://mrdear.cn/categories/%E5%A4%AF%E5%AE%9EJava%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="实战" scheme="https://mrdear.cn/tags/%E5%AE%9E%E6%88%98/"/>
    
    <category term="Java" scheme="https://mrdear.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>实践 -- 二进制与位运算案例</title>
    <link href="https://mrdear.cn/posts/work-design-binary.html"/>
    <id>https://mrdear.cn/posts/work-design-binary.html</id>
    <published>2020-08-21T13:42:14.000Z</published>
    <updated>2020-08-21T13:42:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>二进制以及位运算在编程中很少被使用到，但往往使用到的地方都是很巧妙的设计，本文列举了常见的二进制使用案例，希望对你编程设计有所启发。</p><h2 id="二进制操作"><a href="#二进制操作" class="headerlink" title="二进制操作"></a>二进制操作</h2><p>无论什么语言，二进制操作一般都支持以下指令：</p><ul><li>按位与</li><li>按位或</li><li>左移</li><li>右移(带符号&#x2F;不带符号)</li></ul><p>以下案例均是这些操作的组合。</p><h2 id="枚举类包含与非包含"><a href="#枚举类包含与非包含" class="headerlink" title="枚举类包含与非包含"></a>枚举类包含与非包含</h2><p>枚举场景下，使用二进制能够快速判断当前对象是否拥有该枚举状态，举个例子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">enum</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">A=1</span> <span class="string">(1)</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">B=2</span> <span class="string">(10)</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">C=4</span> <span class="string">(100)</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">D=8</span> <span class="string">(1000)</span></span><br><span class="line"><span class="string">persion</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">小明拥有AB</span> <span class="string">=</span> <span class="number">1</span><span class="string">|2</span> <span class="string">=</span> <span class="number">3</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">小红拥有BCD</span> <span class="string">=</span> <span class="number">2</span><span class="string">|4|8=14</span></span><br></pre></td></tr></table></figure><p>当判断用户是否有哪几个权限时，使用<code>X &amp; U = X</code>，其中X代表要判断的权限，U代表用户当前权限，举个例子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">判断小明是否拥有B：2</span> <span class="string">&amp;</span> <span class="number">3</span> <span class="string">=</span> <span class="number">2</span>  <span class="string">拥有</span></span><br><span class="line"><span class="string">判断小红是否拥有BC：(2|4)&amp;14=6=(2|4)</span> <span class="string">拥有</span></span><br><span class="line"><span class="string">判断小红是否拥有ABC：(1|2|4)&amp;14=6！=(1|2|4)</span> <span class="string">因此不拥有</span></span><br></pre></td></tr></table></figure><p>该案例引申下，可以在任意有限数据基础上判断包含以及不包含，解决相应业务问题。</p><h2 id="分布式ID生成"><a href="#分布式ID生成" class="headerlink" title="分布式ID生成"></a>分布式ID生成</h2><p>分布式ID，即在分布式系统下生成不重复且有序增长的ID序列。已Snowflake算法为例，该算法将64个bit位的Long类型数据进行拆分。首位是符号位，不用，中间41位时间戳，接着是10位的机器id，最后是12位序列号，因此每毫秒最大能产生2的12次方，即4096个序列号。</p><p><img src="http://res.mrdear.cn/uPic/image-20200821154427528.png-default" alt="image-20200821154427528"></p><p>那么回到二进制上，对应bit位的数据该怎么填充？这里填充的实现主要依赖与<strong>位移</strong>操作。举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">时间戳：1000000000 (1597996131000-1596996131000)</span><br><span class="line">机器ID：10</span><br><span class="line">序列号：2048</span><br><span class="line"></span><br><span class="line">那么填充过程如下：</span><br><span class="line">long id = 0L；</span><br><span class="line">id &lt;&lt; 22 | 10 &lt;&lt; 12 | 2048 = 4194304000043008L  ID生成完毕</span><br><span class="line"></span><br><span class="line">拆解下 4194304000043008L</span><br><span class="line"></span><br><span class="line">111011100110101100101000000000 0000001010 100000000000</span><br><span class="line">1000000000                         10          2048</span><br></pre></td></tr></table></figure><p>使用位移以及|操作完成了数据的拼接。这种想法除了分布式ID外，也可以在业务中很高性能的生成各种ID。博主曾经在设计事件系统ID生成逻辑时，使用过类似方案：<code>1bits + 8bits(ip最后一位) + 12bits(事件码编号) + 2bits(时戳类型，毫秒，秒，分钟) + 41bits(时间戳，简单去重可自定义)</code>，因为系统压力不大，所以去重也不需要考虑很复杂，可以说很实用了。</p><h2 id="Java-ReentrantReadWriteLock设计"><a href="#Java-ReentrantReadWriteLock设计" class="headerlink" title="Java ReentrantReadWriteLock设计"></a>Java ReentrantReadWriteLock设计</h2><p>Java的ReentrantReadWriteLock是一个可重入读写锁，即写锁，读锁可以多次被获取，且拥有读读不互斥，读写互斥，写写互斥等特性，实现这些特性则需要标记当前写锁获取次数，读锁获取次数。JDK在这里的实现巧妙的使用了32位INT类型数据，其中高16位标识读写数量，低16位标识写锁数量。比如下图，由于写锁存在，所以必然有一个线程获取到了该锁，并且写锁重入2次，读锁也被获取，且重入1次。</p><p><img src="http://res.mrdear.cn/1529281211.png" alt="img"></p><p>按照这种形式定下来后，JDK需要提供一些快速执行四则运算的方法，如下所示，位移以及位运算结合。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">int</span> <span class="string">state</span> <span class="string">=</span> <span class="string">xxx</span> <span class="string">,标识当前锁状态</span></span><br><span class="line"></span><br><span class="line"><span class="string">获取读锁数量：state</span> <span class="string">&gt;&gt;&gt;</span> <span class="number">16</span></span><br><span class="line"><span class="string">获取写锁数量:</span> <span class="string">state</span> <span class="string">&amp;</span> <span class="string">(ob1111111111111111)</span></span><br><span class="line"><span class="string">写锁+1</span> <span class="string">：</span> <span class="string">state</span> <span class="string">+</span> <span class="number">1</span></span><br><span class="line"><span class="string">读锁+1</span> <span class="string">：state</span> <span class="string">+</span> <span class="string">(ob10000000000000000)</span></span><br></pre></td></tr></table></figure><p>JDK线程池里面也有类似做法，这种有点黑科技的感觉，业务代码还是不要学习这种写法，业务追求的是简单，好理解。</p><h2 id="Bloom-Filter"><a href="#Bloom-Filter" class="headerlink" title="Bloom Filter"></a>Bloom Filter</h2><p>Bloom Filter是利用二进制0，1两个真假属性来判断对应值是否包含的一种策略。以下图为例，key1经过三个不同hash函数(f,g,h)分别映射到三个bit槽，key2同样也是。因为hash冲突以及计算bit槽时取余操作，所以Bloom Filter存在不一定真的存在，但不存在则一定不存在，利用该特性可以实现白名单，黑名单等业务需求，并且存在判断也可以作为一些底层存储的前置拦截，减少穿透请求。</p><p><img src="http://res.mrdear.cn/1552347090.png" alt="img"></p><p>不过这些都不是今天讨论的内容，Bloom Filter给二进制操作上带来的问题是如何构造超长的bit位？这个需要我们了解下。</p><h3 id="JDK-BitSet"><a href="#JDK-BitSet" class="headerlink" title="JDK BitSet"></a>JDK BitSet</h3><p>JDK的做法使用long[]数组来标识bit set，每一个long位64个bit位，那么一个BitSet初始化后，就是N*64长度，通过取余定操作可以先定位到对应long位置，然后再使用位运算修改bit位。</p><h3 id="Redis-BitMap"><a href="#Redis-BitMap" class="headerlink" title="Redis BitMap"></a>Redis BitMap</h3><p>Redis与Java实现类似，不过内部使用的是char[]数组，在C语言中一个char占一个字节，相当于8bit。每一段变小，会造成全遍历统计时数据量庞大，比如统计一共多少个1，Redis在此基础上做了个优化，将对应char[]数组分组，加入128个char一组进行遍历，大大提高了统计效率。</p><p>上述两种做法一般应对于数据经常变化的场景，因为要涉及旧数据的更新操作，不过当使用场景下数据比较稀疏时，还是会造成内存的浪费，因此使用时合理选择映射到bit位的id能够节省不少内存消耗。</p><h2 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h2><p>倒排索引中，倒排表一般会使用跳表或者bitset实现，这里只分析bitset实现方式遇到的挑战以及解法。以ElasticSearch为例，当倒排索引建立后，假设结构如下所示：其中termA,termB,termC为分词之后的词典表，倒排表0则代表当前id不存在，1则代表存在，因此termA有文档4，5，6，7；termB有文档1，2；termC有文档1，4，5。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">termA</span> <span class="string">:[0,0,0,1,1,1,1]</span></span><br><span class="line"><span class="string">termB：[1,1,0,0,0,0,0]</span></span><br><span class="line"><span class="string">termC：[1,0,0,1,1,0,0]</span></span><br></pre></td></tr></table></figure><p>那么要解决的第一个问题，数据怎么存？</p><p>倒排索引不同与上述Bloom Filter场景，在ES中数据往往是以亿位单位的，因此倒排表会非常大，倒排词典数据量一多，磁盘占用就会飞速上涨，另外ES底层使用的Luence是写入后不再变更，也就不存在更新场景，因此使得数据压缩有了很好的前置条件。</p><p>压缩的思路很简单，100个0存储(100，0)即可，而不是真实的存储100个0。Luence在存储中，使用的是位图压缩结构(Roaring Bitmap)来实现优化。如下图所示：</p><p><img src="http://res.mrdear.cn/uPic/1595688058469-08e83c05-fff2-49ad-880d-bb34f44e1096.png-default" alt="image.png"></p><p>如上图所示这一结构以65536为一块区域，进行分块存储，每一块最多标识65536个文档，当文档数小于4096时，Lucene会使用short[]数组存储，short占的空间：2bytes（65535 &#x3D; 2^16-1  是2bytes 能表示的最大数），当超过4096时，则使用bitmap 占的空间: 65536&#x2F;8 &#x3D; 8192bytes，换句话说一个块最大占用内存8192bytes，也就是8kb。</p><p>同样一亿数据量，bitmap结构，必须保存1亿个bit位，但往往这一亿中存在大量不命中的文档id，也就是存在很多个0，此时该算法就能起到很好的压缩效果了。</p><p>第二个问题是<strong>快速取交集</strong>，由于是倒排表是对齐的bit操作，因此可以直接使用&amp;|指令快速求的交集或者并集。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上内容是对工作至今遇到的案例进行总结，如有错误或者遗漏，欢迎留言指正。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;二进制以及位运算在编程中很少被使用到，但往往使用到的地方都是很巧妙的设计，本文列举了常见的二进制使用案例，希望对你编程设计有所启发。&lt;/p&gt;
&lt;h2 id=&quot;二进制操作&quot;&gt;&lt;a href=&quot;#二进制操作&quot; class=&quot;headerlink&quot; title=&quot;二进制操作&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="实战总结" scheme="https://mrdear.cn/categories/%E5%AE%9E%E6%88%98%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="实战" scheme="https://mrdear.cn/tags/%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>OSX--OSX应用快速切换方案</title>
    <link href="https://mrdear.cn/posts/osx_app_switcher.html"/>
    <id>https://mrdear.cn/posts/osx_app_switcher.html</id>
    <published>2020-08-01T04:43:53.000Z</published>
    <updated>2020-08-01T04:43:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>在公司看到不少人还在用Dock切换程序，虽然每个人有自己的习惯，但对于IT人员来说，切换应用这种频繁的操作应该使用更加高效的方式代替，而高效的一个原则，双手无需离开键盘，这里分享下个人使用的方案(感谢堆糖同事，从他们身上学到了这些)，没有最好只有最适合自己，读者可以根据自己的需求选择。</p><h2 id="对使用的程序分类"><a href="#对使用的程序分类" class="headerlink" title="对使用的程序分类"></a>对使用的程序分类</h2><ul><li>日常工作时常用类别：IntelliJ IDEA，VS Code，Microsoft Edge，Typora，Notion，微信等<ul><li>要求快捷键切换</li></ul></li><li>不常用或者打开后不经常切换：音乐，提醒，Clean My Mac，坚果云等<ul><li>使用Alfred快速定位，打开后进入后台，唤醒也使用Alfred</li></ul></li><li>偶尔一次使用： 迅雷，阿里旺旺，IINA，幕布<ul><li>使用alfred快速定位，用完就cmd + q清理</li></ul></li></ul><p>由上面可以总结为两种形式，一种是快捷键做到在各个窗口之间，一种是alfred定位程序，两种分别使用不同软件定制即可。</p><h2 id="快捷键切换"><a href="#快捷键切换" class="headerlink" title="快捷键切换"></a>快捷键切换</h2><p>快捷键切换是使用最频繁的场景，因此为了达到完美体验，我总结了以下流程图，流程图的原则是定位到不同的应用，不存在则启动应用，存在则切换到该应用，同时应对多屏幕下多窗口，多次相同快捷键能够在窗口之间互相切换。<img src="http://res.mrdear.cn/uPic/mac-app-switch.png-default"></p><p>我选择的软件是<a href="http://www.hammerspoon.org/">hammerspoon</a>，该程序提供了lua脚本与mac os交互的能力，定制脚本如下所示，需要的可以根据自己需要改造。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--123</span></span><br><span class="line">hs.hotkey.bind(&#123; <span class="string">&quot;alt&quot;</span> &#125;, <span class="string">&quot;1&quot;</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">    toggleAppByBundleId(<span class="string">&quot;com.bohemiancoding.sketch3&quot;</span>)</span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line">hs.hotkey.bind(&#123; <span class="string">&quot;alt&quot;</span> &#125;, <span class="string">&quot;2&quot;</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">    toggleAppByBundleId(<span class="string">&quot;com.sequelpro.SequelPro&quot;</span>)</span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line"><span class="comment">-- qwe</span></span><br><span class="line">hs.hotkey.bind(&#123; <span class="string">&quot;alt&quot;</span> &#125;, <span class="string">&quot;q&quot;</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">    toggleAppByBundleId(<span class="string">&quot;com.tencent.qq&quot;</span>)</span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line">hs.hotkey.bind(&#123; <span class="string">&quot;alt&quot;</span> &#125;, <span class="string">&quot;w&quot;</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">    toggleAppByBundleId(<span class="string">&quot;com.tencent.xinWeChat&quot;</span>)</span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line">hs.hotkey.bind(&#123; <span class="string">&quot;alt&quot;</span> &#125;, <span class="string">&quot;e&quot;</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">    toggleAppByBundleId(<span class="string">&quot;com.apple.Notes&quot;</span>)</span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line"><span class="comment">-- asd</span></span><br><span class="line">hs.hotkey.bind(&#123; <span class="string">&quot;alt&quot;</span> &#125;, <span class="string">&quot;a&quot;</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">    toggleAppByBundleId(<span class="string">&quot;com.microsoft.VSCode&quot;</span>)</span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line">hs.hotkey.bind(&#123; <span class="string">&quot;alt&quot;</span> &#125;, <span class="string">&quot;s&quot;</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">    toggleAppByBundleId(<span class="string">&quot;com.apple.finder&quot;</span>)</span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line">hs.hotkey.bind(&#123; <span class="string">&quot;alt&quot;</span> &#125;, <span class="string">&quot;d&quot;</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">    toggleAppByBundleId(<span class="string">&quot;com.microsoft.edgemac&quot;</span>)</span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line"><span class="comment">-- zxc</span></span><br><span class="line">hs.hotkey.bind(&#123; <span class="string">&quot;alt&quot;</span> &#125;, <span class="string">&quot;z&quot;</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">    toggleAppByBundleId(<span class="string">&quot;notion.id&quot;</span>)</span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line">hs.hotkey.bind(&#123; <span class="string">&quot;alt&quot;</span> &#125;, <span class="string">&quot;x&quot;</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">    toggleAppByBundleId(<span class="string">&quot;com.jetbrains.intellij&quot;</span>)</span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- else</span></span><br><span class="line">hs.hotkey.bind(&#123; <span class="string">&quot;alt&quot;</span> &#125;, <span class="string">&quot;m&quot;</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">    toggleAppByBundleId(<span class="string">&quot;com.apple.mail&quot;</span>)</span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 鼠标位置</span></span><br><span class="line">mousePositions = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toggleAppByBundleId</span><span class="params">(appBundleID)</span></span></span><br><span class="line"><span class="comment">--    获取当前最靠前的应用,保存鼠标位置</span></span><br><span class="line">    <span class="keyword">local</span> frontMostApp = hs.application.frontmostApplication()</span><br><span class="line">    <span class="keyword">local</span> mainWindow = frontMostApp:mainWindow()</span><br><span class="line">    <span class="keyword">if</span> mainWindow:isStandard() <span class="keyword">then</span></span><br><span class="line">        mousePositions[frontMostApp:mainWindow():id()] = hs.mouse.getAbsolutePosition()</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 两者重复时,寻找下一个该窗口</span></span><br><span class="line">    <span class="keyword">if</span> frontMostApp:bundleID() == appBundleID <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">local</span> wf = hs.window.filter.new&#123;frontMostApp:name()&#125;</span><br><span class="line">        <span class="keyword">local</span> locT = wf:getWindows(&#123;hs.window.filter.sortByFocusedLast&#125;)</span><br><span class="line">        <span class="keyword">if</span> locT <span class="keyword">and</span> #locT &gt; <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">local</span> windowId = frontMostApp:mainWindow():id()</span><br><span class="line">            <span class="keyword">for</span> _, value <span class="keyword">in</span> <span class="built_in">pairs</span>(locT) <span class="keyword">do</span></span><br><span class="line">                <span class="keyword">if</span> value:id() ~= windowId <span class="keyword">then</span></span><br><span class="line">                    value:focus()</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            frontMostApp:hide()</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">-- 不存在窗口时,启动app</span></span><br><span class="line">        <span class="keyword">local</span> launchResult = hs.application.launchOrFocusByBundleID(appBundleID)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> launchResult <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 调整鼠标位置</span></span><br><span class="line">    frontMostApp = hs.application.applicationsForBundleID(appBundleID)[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> point = mousePositions[appBundleID]</span><br><span class="line">    <span class="keyword">if</span> point <span class="keyword">then</span></span><br><span class="line">        hs.mouse.setAbsolutePosition(point)</span><br><span class="line">        <span class="keyword">local</span> currentSc = hs.mouse.getCurrentScreen()</span><br><span class="line">        <span class="keyword">local</span> tempSc = frontMostApp:mainWindow():screen()</span><br><span class="line">        <span class="keyword">if</span> currentSc ~= tempSc <span class="keyword">then</span></span><br><span class="line">            setMouseToCenter(frontMostApp)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="comment">--    找不到则转移到该屏幕中间</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        setMouseToCenter(frontMostApp)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setMouseToCenter</span><span class="params">(frontMostApp)</span></span></span><br><span class="line">    <span class="keyword">local</span> mainWindow = frontMostApp:mainWindow()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> mainWindow <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">local</span> mainFrame = mainWindow:frame()</span><br><span class="line">    <span class="keyword">local</span> mainPoint = hs.geometry.point(mainFrame.x + mainFrame.w /<span class="number">2</span>, mainFrame.y + mainFrame.h /<span class="number">2</span>)</span><br><span class="line">    hs.mouse.setAbsolutePosition(mainPoint)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="Alfred切换"><a href="#Alfred切换" class="headerlink" title="Alfred切换"></a>Alfred切换</h2><p>Alfred切换不需要配置什么了，下载Alfred后，唤醒窗口，输入关键字即可快速匹配跳转。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>有更好的方式，欢迎分享</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在公司看到不少人还在用Dock切换程序，虽然每个人有自己的习惯，但对于IT人员来说，切换应用这种频繁的操作应该使用更加高效的方式代替，而高效的一个原则，双手无需离开键盘，这里分享下个人使用的方案(感谢堆糖同事，从他们身上学到了这些)，没有最好只有最适合自己，读者可以根据自己</summary>
      
    
    
    
    <category term="杂七杂八" scheme="https://mrdear.cn/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"/>
    
    
    <category term="OSX" scheme="https://mrdear.cn/tags/OSX/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记 -- 透视HTTP协议</title>
    <link href="https://mrdear.cn/posts/readnote-http.html"/>
    <id>https://mrdear.cn/posts/readnote-http.html</id>
    <published>2020-07-19T11:51:30.000Z</published>
    <updated>2020-07-19T11:51:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近上班路上补完了这个专栏，对HTTP有了更加深的了解，专栏写的非常棒，尤其是HTTP2那一部分，把HTTP&#x2F;2对HTTP&#x2F;1的改进点，以及为什么改进，改进方式说的很通俗易懂，感兴趣的推荐去极客时间内购买专栏学习。</p><p>notion嵌套不了iframe，因此直接贴地址了。</p><p><a href="https://www.notion.so/HTTP-752251d6ad0b4951a1948a4d592a59a3">读书笔记 – 透视HTTP协议</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近上班路上补完了这个专栏，对HTTP有了更加深的了解，专栏写的非常棒，尤其是HTTP2那一部分，把HTTP&amp;#x2F;2对HTTP&amp;#x2F;1的改进点，以及为什么改进，改进方式说的很通俗易懂，感兴趣的推荐去极客时间内购买专栏学习。&lt;/p&gt;
&lt;p&gt;notion嵌套不了if</summary>
      
    
    
    
    <category term="读书笔记" scheme="https://mrdear.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="读书笔记" scheme="https://mrdear.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Mockito -- Mockito原理</title>
    <link href="https://mrdear.cn/posts/framework-mockito.html"/>
    <id>https://mrdear.cn/posts/framework-mockito.html</id>
    <published>2020-07-19T01:40:05.000Z</published>
    <updated>2020-07-19T01:40:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近开始使用Mockito进行单元测试，本篇文章是理解Mockito并对其常见测试方式进行归纳总结。</p><h2 id="Mocito体系"><a href="#Mocito体系" class="headerlink" title="Mocito体系"></a>Mocito体系</h2><p>从使用角度，可以将Mockito分为插桩以及验证，使用者只需要关心模块提供的能力，不需要太过于深入了解。</p><ul><li>插桩<ul><li>ArgumentMatcher：参数匹配工具，比如Mokito.eq(“屈定”)类似语句会创建该匹配</li><li>OngoingStubbing：mock入口类，用于打桩，应对 when() thenXXX形式</li><li>Stubber：mock入口类，用于打桩，应对doXXX when()形式</li></ul></li><li>验证<ul><li>VerificationMode：验证器，用于验证mock对象行为，常见实现有times()</li><li>InOrder：验证器的一种，用于验证执行顺序</li><li>ArgumentCaptor：用于被mock对象参数捕获</li></ul></li></ul><h2 id="Mockito原理"><a href="#Mockito原理" class="headerlink" title="Mockito原理"></a>Mockito原理</h2><p>想要在开发中随心所欲的使用Mockito达到单测目的，了解Mockito原理是必须的。当我们在用Mockito时，经常写出以下类似代码，从逻辑上可以分为四部分：定义Mock对象，定义方法返回值，调用<strong>单测方法</strong>(这里直接调用mock方法，方便阐述原理)，验证业务结果。那么每一步骤对于Mockito分别做了什么呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UserService</span> <span class="variable">mockService</span> <span class="operator">=</span> Mockito.mock(UserService.class);</span><br><span class="line"></span><br><span class="line">Mockito.when(mockService.queryUser(Mockito.eq(<span class="string">&quot;xxx&quot;</span>)))</span><br><span class="line">    .thenReturn(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;屈定&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> mockService.queryUser(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">Assertions.assertEquals(<span class="string">&quot;屈定&quot;</span>, user.getOwner());</span><br></pre></td></tr></table></figure><p>简单来看，我们可以猜想到所谓的Mock测试技术原理应是预先定义好该方法返回值，使用AOP技术拦截对应的方法执行，当拦截直接返回对应的值，从而达到Mock效果，如下图所示：<br><img src="http://res.mrdear.cn/uPic/mockito_simple_struct.png-default"></p><p>问题回到Mockito，可以提出以下三个问题为思考的切入点：</p><ul><li>Mockito是如何创建AOP对象的</li><li>Mockito是如何预先定义方法返回值</li><li>Mockito是如何拦截方法执行并返回给定mock值的</li></ul><h3 id="Mockito是如何创建AOP对象的"><a href="#Mockito是如何创建AOP对象的" class="headerlink" title="Mockito是如何创建AOP对象的"></a>Mockito是如何创建AOP对象的</h3><p>Mockito AOP对象的创建，对应代码的第一行<code>Mockito.mock(UserService.class)</code>，贴一下相关代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># Mockito.mock(UserService.class)</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">mock</span><span class="params">(Class&lt;T&gt; classToMock, MockSettings mockSettings)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> MOCKITO_CORE.mock(classToMock, mockSettings);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># MOCKITO_CORE.mock(xxxx)</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">mock</span><span class="params">(Class&lt;T&gt; typeToMock, MockSettings settings)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!MockSettingsImpl.class.isInstance(settings)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Unexpected implementation of &#x27;&quot;</span> + settings.getClass().getCanonicalName() + <span class="string">&quot;&#x27;\n&quot;</span> + <span class="string">&quot;At the moment, you cannot provide your own implementations of that class.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">MockSettingsImpl</span> <span class="variable">impl</span> <span class="operator">=</span> MockSettingsImpl.class.cast(settings);</span><br><span class="line">    MockCreationSettings&lt;T&gt; creationSettings = impl.build(typeToMock);</span><br><span class="line">    <span class="type">T</span> <span class="variable">mock</span> <span class="operator">=</span> createMock(creationSettings);</span><br><span class="line">    mockingProgress().mockingStarted(mock, creationSettings);</span><br><span class="line">    <span class="keyword">return</span> mock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，<code>Mockito</code>会使用全局静态变量<code>MOCKITO_CORE</code>创建代理对象，核心逻辑都在<code>MockitoCore</code>中，我们不必关心很细节，所以仍然按照带着问题的方式去探索。</p><p>**1.**创建中的<code>MockSettings</code>可以做什么？</p><p><code>MockSettings</code>可以针对一个mock对象创建做额外的配置，比如使用指定构造函数进行初始化，设置mock的一些调用监听器，以及mock拦截后默认返回值，一般创建时不指定，系统默认为<code>new MockSettingsImpl().defaultAnswer(RETURNS_DEFAULTS)</code>。</p><p>**2.**代理对象创建使用的是什么技术？对应拦截器实现是什么？</p><p>对应细节都在<code>createMock(...)</code>方法中，这里就不贴代码，直接说结论。Mockito内部有一套插件机制，其中生成代理类对应<code>MockMaker</code>扩展点，默认实现为<code>org.mockito.internal.creation.bytebuddy.SubclassByteBuddyMockMaker</code>，即用ByteBuddy技术生成对应代理类，<code>ByteBuddy</code>博主了解的不是很多，但根据<code>SubclassBytecodeGenerator</code>处的源码可以发现其本质是使用<strong>继承</strong>动态创建需要代理类的子类，然后复写对应方法达到拦截目的，因此也说明了Mockito不支持final类，不支持static，private等方法mock的原因，不过这个算不上缺点，private方法外部根本不用关心，因此无需考虑mock，static方法作为全局使用的工具类型方法，如果也需要mock那么说明存在坏代码的味道，最好的做法是重构，而不是想方设法的mock。另外Mockito提供了<code>InlineByteBuddyMockMaker</code>实现类，该类利用<strong>Instrumentation API</strong>特性实现了静态方法，私有方法，final方法等拦截，更加强大，该特性还在试验中，感兴趣的可以尝试。</p><p><code>ByteBuddy</code>代理类默认拦截器为<code>org.mockito.internal.creation.bytebuddy.MockMethodInterceptor</code>类。该类面向ByteBuddy提供的调用入口，内部会将参数包装后，给到真正的Mock拦截器<code>org.mockito.invocation.MockHandler</code>，进而决定返回或者插桩定义。<code>MockHandler</code>的实现可以理解为下图结构，<br><img src="http://res.mrdear.cn/uPic/mockito_method_handler.png-default"></p><p>**3.**Mockito如何保证线程安全</p><p>在测试中会开启多线程测试，而Mockito又是一个静态调用形式，内部MockitoCore是全局共享变量，如果没有一定处理措施，必然会导致并发冲突。Mockito的解决方案是使用ThreadLocal，其提供<code>MockingProgress</code>类存储当前mock进度信息，提供<code>ThreadSafeMockingProgress</code>使其与ThreadLocal进行绑定，线程安全和mock本身原理关系不是很大，这里不多做分析，具体细节感兴趣的可以去了解下。</p><h3 id="Mockito是如何预先定义方法返回值"><a href="#Mockito是如何预先定义方法返回值" class="headerlink" title="Mockito是如何预先定义方法返回值"></a>Mockito是如何预先定义方法返回值</h3><p>常用的预定义方法返回值主要有两种形式<code>when() thenXXX</code>，<code>doXXX when</code>，很多同学不理解这两个的区别，事实不然，两者的存在都很有必要，按照上述拦截后执行逻辑，分别分析两者的不同点。</p><p>**1.**when() thenXXX是如何预定义值的</p><p>还是以上述为例<code>Mockito.when(mockService.queryUser(Mockito.eq(&quot;xxx&quot;))).thenReturn(new User(&quot;屈定&quot;));</code>，Java是顺序执行代码的，那么针对该部分代码执行顺序可以拆解为以下几个步骤，下面分别分析：</p><ul><li>Mockito.eq(“xxx”)<ul><li>往<code>MockingProgress</code>添加一个equal的ArgumentMatcher，<code>MockingProgress</code>使用Stack结构存储ArgumentMatcher，因此可以推测出，这里默认规则在方法拦截前所有的ArgumentMatcher都会按照执行顺序入栈。</li></ul></li><li>mockService.queryUser<ul><li>mockService已经被代理了，因此该方法会直接进入<code>org.mockito.internal.handler.MockHandlerImpl#handle</code>中，此时MockHandler发现该是一个方法调用，接着去查找对应的ArgumentMatcher与其绑定，存到Stub Container中，mockContainer结构可以看作为<code>UserService+queryUser+eq(xxx)  -&gt; NULL</code></li></ul></li><li>Mockito.when<ul><li>这里when接收到的参数实际上是NULL，因为上面的queryUser并没有对应值与其绑定，此时When相当于返回<code>MockingProgress</code>的mock进度</li></ul></li><li>new User(“屈定”)<ul><li>普通创建对象</li></ul></li><li>OngoingStubbing.thenReturn<ul><li>OngoingStubbing则是<code>MockingProgress</code>中当前mock进度，thenReturn会创建<code>Returns</code>对象，该对象会与上一个方法调用进行绑定，因此执行完毕后，mockContainer结构可以看作<code>UserService+queryUser+eq(xxx)  -&gt; User(“屈定”)</code></li></ul></li></ul><p>**2.**doXXX when()是如何预定义的</p><p>在doXXX when()模式下，一般这样<code>Mockito.doReturn(new User(&quot;屈定&quot;)).when(mockService).queryUser(Mockito.eq(&quot;xxx&quot;));</code>定义mock，按照同样步骤进行拆解：</p><ul><li>new User(“屈定”)<ul><li>普通创建对象</li></ul></li><li>Mockito.doReturn<ul><li>此时该方法创建的是一个<code>StubberImpl</code>对象，与上述流程是不一样的。该类有成员变量<code>List&lt;Answer&lt;?&gt;&gt; answers</code>，此方法执行会将对应Answer对象暂存到该集合中</li></ul></li><li>Stubber.when<ul><li>when的入参是被mock对象，那么就能拿到<code>MockingProgress</code>获取当前mock进度，之后再把成员变量<code>List&lt;Answer&lt;?&gt;&gt; answers</code>与当前mock对象进行绑定，此时mockContainer结构可以看作<code>NULL -&gt; User(“屈定”)</code></li></ul></li><li>Mockito.eq(“xxx”)<ul><li>同上，往<code>MockingProgress</code>添加一个equal的ArgumentMatcher</li></ul></li><li>UserService.queryUser<ul><li>同上，进入到拦截器，然后与对应Answer绑定，mockContainer结构可以看作为<code>UserService+queryUser+eq(xxx)  -&gt; User(“屈定”)</code></li></ul></li></ul><p>**3.**两者的不同点带来什么不同</p><p>按照上述流程分析，无论是<code>when() thenXXX</code>还是<code>doXXX when()</code>，最终都能得到<code>UserService+queryUser+eq(xxx)  -&gt; User(“屈定”)</code>的结构，那两者的不同点是为了什么呢？<br>在Mock代理中，因为Mock都会被拦截掉，并不会有任何真实调用，两者所产生的效果是没有区别的。<code>doXXX when()</code>主要是用在Spy和void返回形式上，在Spy模式下，<code>UserService.queryUser</code>会产生真实调用，<code>doXXX when()</code>的做法是将调用放在最后一步，调用时，已经知道对应的Answer了，而<code>when() thenXXX</code>则是在最后一步才知道Answer，无法做拦截。</p><h3 id="Mockito是如何拦截方法执行并返回给定mock值的"><a href="#Mockito是如何拦截方法执行并返回给定mock值的" class="headerlink" title="Mockito是如何拦截方法执行并返回给定mock值的"></a>Mockito是如何拦截方法执行并返回给定mock值的</h3><p>第二个问题分析过程中实际上已经回答了这个问题，在Mock构建完毕后，对应的方法调用Invocation以及Answer是一一对应绑定起来的，因此只需要找到对应的stub，然后发现有Answer直接返回即可</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>上文主要来源于源码翻查以及网上一些资料，如有错误，还请指出。</p><p><a href="https://www.infoq.cn/article/mockito-design">反模式的经典 - Mockito 设计解析</a><br><a href="https://www.javadoc.io/doc/org.mockito/mockito-core/latest/org/mockito/Mockito.html">Mockito官方文档</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近开始使用Mockito进行单元测试，本篇文章是理解Mockito并对其常见测试方式进行归纳总结。&lt;/p&gt;
&lt;h2 id=&quot;Mocito体系&quot;&gt;&lt;a href=&quot;#Mocito体系&quot; class=&quot;headerlink&quot; title=&quot;Mocito体系&quot;&gt;&lt;/a&gt;Moci</summary>
      
    
    
    
    <category term="框架与中间件" scheme="https://mrdear.cn/categories/%E6%A1%86%E6%9E%B6%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="Mockito" scheme="https://mrdear.cn/tags/Mockito/"/>
    
  </entry>
  
  <entry>
    <title>设计模式 -- 进程内事件机制设计</title>
    <link href="https://mrdear.cn/posts/design-patterns-event_design.html"/>
    <id>https://mrdear.cn/posts/design-patterns-event_design.html</id>
    <published>2020-06-14T09:31:01.000Z</published>
    <updated>2020-06-14T09:31:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>在如今动不动分布式环境下，进程内事件机制有点被遗忘，以至于很少使用这一设计。最近在实现一个事件中心机制模型，将应用内一些外部驱动事件都统一入口以及执行，本文则对一些常见进程内事件机制设计做一次梳理，供设计时提供参考。</p><h2 id="事件机制模型以及优势"><a href="#事件机制模型以及优势" class="headerlink" title="事件机制模型以及优势"></a>事件机制模型以及优势</h2><p>事件机制很好理解，发布者发布了一个事件，经过一些操作，投递到了订阅者，订阅者根据接收到相应的事件，执行对应业务逻辑，在这个流程中，可以分析出事件模型的三个必要条件</p><ul><li>发布者：产生事件</li><li>订阅者：消费事件</li><li>连接：发布者与订阅者沟通的方式，进程内由于共享内存，内存即是连接，因此该点可以不考虑。</li></ul><p>也因此事件机制主流实现方式是发布订阅模式，MQ可以理解为是分布式下的事件机制设计实现，<a href="https://mrdear.cn/posts/design-patterns-observer.html">观察者模式</a>可以理解为进程内的事件机制设计实现，那么使用事件机制的优势是什么？我总结了以下几点：</p><ul><li>事件机制设计是一种完全解耦的设计模式，发布者与订阅者之间并不是强耦合状态，有人可能说观察者模式中，Subject持有全部的Observer，这里虽然代码上有耦合，但是从设计上来说，Subject获取Observer的目地只是为了能够调用对应方法，这一过程完全可以利用IOC做到全自动化，即添加一个Observer，对应的Subject就能自动发现新的Observer。</li><li>事件机制可以解决低层级无法访问高层级，分层架构中，层级之间不允许循环依赖，那么低层级无法访问高层级，事件机制则可以穿透层级，提供跨层访问能力</li><li>事件机制扩展性很强，事件机制相当于在事件以及订阅者之间加了一个中间层，因此可以做很多扩展，比如利用队列削峰，利用订阅者嵌套实现冒泡。</li><li>等等</li></ul><p>接下来会分析Spring ApplicationListener以及Guava EventBus设计。</p><h2 id="Spring-ApplicationListener"><a href="#Spring-ApplicationListener" class="headerlink" title="Spring ApplicationListener"></a>Spring ApplicationListener</h2><p>Spring ApplicationListener的使用很方便，对应的Spring Bean只需要实现<code>ApplicationListener</code>接口，并指定对应的事件类型即可，Spring在启动中会通过IOC容器将该订阅任务添加到<code>ApplicationEventMulticaster</code>中，如下代码所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserNotifyEventTask</span> <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;UserNotifyEvent&gt; &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> NotifyRepo notifyRepo;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(UserNotifyEvent event)</span> &#123;</span><br><span class="line">        <span class="type">NotifyDO</span> <span class="variable">notifyDO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NotifyDO</span>();</span><br><span class="line">        notifyDO.setTitle(event.getTitle());</span><br><span class="line">        notifyDO.setCnt(event.getCnt());</span><br><span class="line">        notifyRepo.insert(notifyDO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>背后原理是什么样子呢？Spring的事件机制是典型的观察者模式，其主要目地是在Spring框架初始化生命周期过程中提供各阶段的通知能力，当然也支持自定义事件，用于业务系统。参考发布订阅模式，其中发布者为<code>ApplicationEventMulticaster</code>，订阅者为<code>ApplicationListener</code>，事件模型<code>ApplicationEvent</code>，进程内通知，因此发布者直接持有了全部的订阅者，基本流程如下：<br><img src="http://res.mrdear.cn/spring-eventlistener.png"></p><p>其中<code>ApplicationEventMulticaster</code>在Spring容器ApplicationContext创建时会一并创建，<code>ApplicationEventMulticaster</code>唯一实现类为<code>SimpleApplicationEventMulticaster</code>，如名称所示，就是一个简单的执行Listener的类，虽然提供了<code>taskExecutor</code>变量，但默认情况下为同步调用。Spring这一套事件机制设计的目地更多的考虑是内部事件分发，比如你的类感兴趣Spring容器刷新事件，则可以订阅<code>ContextRefreshedEvent</code>事件，较少的考虑到业务中事件处理，因此不建议业务中直接使用该模块作为进程内通信方式。</p><h2 id="Guava-EventBus"><a href="#Guava-EventBus" class="headerlink" title="Guava EventBus"></a>Guava EventBus</h2><p>Guava的EventBus使用也很简单，以下面单测为例，使用<code>@Subscribe</code>注解声明一个订阅者，然后创建对应的EventBus，并注册订阅者，接着发布事件，即可完成投递动作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EventBusTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPostEvent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">EventBus</span> <span class="variable">eventBus</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EventBus</span>(<span class="string">&quot;unit-test&quot;</span>);</span><br><span class="line">        eventBus.register(<span class="keyword">new</span> <span class="title class_">EventBusTest</span>());</span><br><span class="line">        eventBus.post((<span class="keyword">new</span> <span class="title class_">UserNotifyEvent</span>(<span class="string">&quot;quding log out&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@com</span>.google.common.eventbus.Subscribe</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">subscribe</span><span class="params">(UserNotifyEvent event)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;subscribe event &quot;</span> + event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比Spring事件设计，Guava将进程内的事件驱动机制该有的组件更加细分模块，如下所示：</p><ul><li>EventBus：事件发布者(事件总线)</li><li>SubscriberRegistry：事件订阅者管理</li><li>Dispatcher：事件分发</li></ul><p><img src="http://res.mrdear.cn/guava-event-bus.png"></p><p>总体实现比较简单，<code>EventBus</code>作为入口提供事件注册以及发布能力，这里也可以使用<code>AsyncEventBus</code>提供的异步能力进行事件处理。当注册一个事件时，<code>EventBus</code>会将其转交到<code>SubscriberRegistry</code>，<code>SubscriberRegistry</code>根据定义逻辑解析出来事件处理方法，比如guava会解析提交类中被<code>@Subscribe</code>标注的方法作为事件订阅者，其第一个入参为其感兴趣的事件。当产生一个事件后，<code>EventBus</code>会将从<code>SubscriberRegistry</code>中获取到对应的订阅者，然后一并转交给<code>Dispatcher</code>进行处理，guava中<code>Dispatcher</code>的实现主要是依赖队列，当直接同步执行时，为直接调用，当异步执行时，则需要一个共享队列进行排队，当需要顺序执行时，则需要队列绑定到当前ThreadLocal，对类似场景Guava有着不同的封装实现。<br>Guava的这一套API一直标准为BETA状态，但代码逻辑比简单，业务中直接使用也是很推荐的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>理解了观察者模式后，事件机制实现原理也很容易理解，事件机制最大的优势是彻底解耦，合理使用会让代码设计上更加高内聚低耦合。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在如今动不动分布式环境下，进程内事件机制有点被遗忘，以至于很少使用这一设计。最近在实现一个事件中心机制模型，将应用内一些外部驱动事件都统一入口以及执行，本文则对一些常见进程内事件机制设计做一次梳理，供设计时提供参考。&lt;/p&gt;
&lt;h2 id=&quot;事件机制模型以及优势&quot;&gt;&lt;a h</summary>
      
    
    
    
    <category term="设计模式专题" scheme="https://mrdear.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%93%E9%A2%98/"/>
    
    
    <category term="设计模式" scheme="https://mrdear.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式 -- 享元模式的思考</title>
    <link href="https://mrdear.cn/posts/design-patterns-flyweight.html"/>
    <id>https://mrdear.cn/posts/design-patterns-flyweight.html</id>
    <published>2020-05-10T01:08:14.000Z</published>
    <updated>2020-05-10T01:08:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>享元意思为共享的单元，享元模式的目地是针对不可变对象可以复用，以达到节省内存的目地。在一些特殊的业务场景上能发挥出巨大的威力，本文将分析享元模式以及举出一些应用案例。</p><h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p>享元模式很好理解，即针对<strong>不可变对象</strong>的<strong>复用</strong>。</p><p>对象不可变指的是对象构建成功后，不能通过访问方法改变对象属性，因为享元模式下，对象会被多处使用，如果可变则造成不一致现象，这一点很好理解。另外怎么复用呢？常见的手段是使用一个Map存下来已经产生的对象，当新建对象时，如果Map中已经存在需要的对象，则直接返回已存在对象地址，达到复用目地。</p><p>享元模式本身很简单，个人认为需要掌握的是这种<strong>对象复用思想</strong>，在实现对应业务时，能敏感的发现可复用场景，下面从几个案例中来感受下其威力。</p><h2 id="JDK中享元模式应用"><a href="#JDK中享元模式应用" class="headerlink" title="JDK中享元模式应用"></a>JDK中享元模式应用</h2><p>熟悉Java的同学，或多或少都遇到过下面问题，按理来说，<code>Integer</code>属于对象，每一次创建都会开辟新的内存，所以即使相同的大小，其内存地址不一致，会被<code>==</code>判定为两个对象，但实际情况中[-128，127]之间的数字，JDK使用了享元模式，复用了这部分的对象，JDK实现者认为[-128，127]之间的数字一般为编程中高频数字，如果每次都new产生新对象，比较浪费内存，如果是复用情况下，即使多次声明，内存中只会有一份对象存在，能够节省大量无谓的内存消耗。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">var1</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">var2</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">var3</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">var4</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(var1 == var2); <span class="comment">// true</span></span><br><span class="line">System.out.println(var3 == var4); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h2 id="字符串常量池与享元模式"><a href="#字符串常量池与享元模式" class="headerlink" title="字符串常量池与享元模式"></a>字符串常量池与享元模式</h2><p>JDK中提供了字符串常量池，也就是字符串缓存，在Java中动态创建的字符串可以使用<code>intern()</code>方法让其进入常量池，关于更多常量池分析可以参考我另一篇文章<a href="https://mrdear.cn/posts/java-string-pool.html">Java – 字符串常量池介绍</a>。那么常量池机制本身就是享元模式思想，针对重复字符串对象达到复用目地，从而节省内存消耗。</p><p>Twitter曾分享过利用字符串常量池享元方式优化内存案例，该案例中Twitter用户登录后需要在session中保存用户地理位置信息，有国家，省份，城市等，当网站日活上去后，session中的地理位置字符串信息将占据大量内存。简单分析下，地理位置信息为字符串格式，具备不可变属性，且在该业务中重复度很高，因此可以利用字符串常量池复用相应的字符串，这本质上也是享元模式的一种运用。</p><h2 id="数据库表结构设计与享元模式"><a href="#数据库表结构设计与享元模式" class="headerlink" title="数据库表结构设计与享元模式"></a>数据库表结构设计与享元模式</h2><p>享元模式虽然为应用代码设计的产物，但在数据库表结构设计上也经常有类似思想运用。比如要设计一款RSS阅读器，用户可以自定义订阅列表，那么怎么做？</p><p><strong>做法一</strong><br>做法一是记录每一个用户的地址，然后后台定时任务为每一个用户更新对应的RSS信息，订阅表如下树形结构所示。这样做有什么坏处？考虑到2-8原则，即80%用户都会订阅常见的一些RSS，那么这张表中RSS地址重复度就很高，针对每一个用户更新对应RSS信息则相当于做了很多重复的订阅拉取动作。</p><ul><li>用户订阅表<ul><li>用户id</li><li>RSS地址</li></ul></li></ul><p><strong>做法二：使用享元思想</strong><br>做法二是针对RSS地址，单独维护一张表，用户订阅时只需要关联到RSS id，RSS订阅则不需要考虑用户维度，定时去更新RSS源地址中所有地址，两者完全解耦开来。此时<code>RSS源地址表</code>相当于享元思想中<strong>被共享的单元</strong>，之所以可以这样设计，因为无论用户订阅怎么变化，RSS地址不会变化，因此具备不可变性，且用户订阅中RSS地址重复度很高，具备高重复度这一特点。</p><ul><li>用户订阅表<ul><li>用户id</li><li>RSS id</li></ul></li><li>RSS源地址表<ul><li>RSS id</li><li>RSS 地址</li></ul></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>享元模式很简单，很好理解，关键时刻能发挥出巨大作用，但什么时候使用享元模式或者说需要考虑享元模式呢？根据上面案例，我觉得可以总结为以下两点</p><ul><li>对象能做到不可变</li><li>对应业务中，对象重复度很高</li></ul><p>这两点情况下，大多数情况都能够使用享元模式进行优化。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://time.geekbang.org/column/intro/250">极客时间 – 设计模式之美专栏</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;享元意思为共享的单元，享元模式的目地是针对不可变对象可以复用，以达到节省内存的目地。在一些特殊的业务场景上能发挥出巨大的威力，本文将分析享元模式以及举出一些应用案例。&lt;/p&gt;
&lt;h2 id=&quot;享元模式&quot;&gt;&lt;a href=&quot;#享元模式&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="设计模式专题" scheme="https://mrdear.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%93%E9%A2%98/"/>
    
    
    <category term="设计模式" scheme="https://mrdear.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java -- 抽象类与接口的思考</title>
    <link href="https://mrdear.cn/posts/java_abstract_interface.html"/>
    <id>https://mrdear.cn/posts/java_abstract_interface.html</id>
    <published>2020-05-05T11:18:15.000Z</published>
    <updated>2020-05-05T11:18:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在极客时间学习设计模式时，回顾了下抽象类与接口的设计意义，以及如何决定什么时候使用抽象类或者接口，写了两三年代码，也算有点想法，本文分享下自己的观点。</p><h2 id="接口与抽象类的意义"><a href="#接口与抽象类的意义" class="headerlink" title="接口与抽象类的意义"></a>接口与抽象类的意义</h2><p>首先两者本身就很类似，尤其是JDK8之后，接口增加了default方法，允许接口中有部分实现逻辑，这个阶段虽然大多数接口与抽象类都可以互相替换，但他们的侧重点不同。</p><ul><li>抽象类<ul><li>描述的是is - a关系</li><li>侧重点在于代码复用，比如大多数Abstract&#x2F;Base开头的类</li><li>抽象类更多的表示某一类事物，比如人，分为教师，工人等等，描述面向对象编程中对象关系，底层仍要关心这个是哪一类对象</li></ul></li><li>接口<ul><li>描述的是has - a关系或者说 behavior like更形象</li><li>侧重点在于解耦，解耦的方式则是利用接口定义规范制约实现</li><li>接口更多的标识某一行为，比如排序接口，底层可以不关心实现</li></ul></li></ul><h2 id="什么时候用抽象类，什么时候用接口"><a href="#什么时候用抽象类，什么时候用接口" class="headerlink" title="什么时候用抽象类，什么时候用接口"></a>什么时候用抽象类，什么时候用接口</h2><p>了解上述区分点后，对于该问题，应该要从实现考虑，当你描述的关系为is - a时，那么抽象类更加合适，如果has - a时，那么接口合适。往往大多数时候两者都具备，所以经常见到三层继承结构，最上层是接口，中间抽象类，叶子节点为实现类，比如Mybatis中Executor实现，最上层接口Executor标识has -a 关系，表示Executor是一个执行器，有着这些操作方法。中间BaseExecutor侧重于代码复用，描述的是is - a关系，表示这一类实现都是Executor，方便子类实现。<br><img src="http://res.mrdear.cn/1588674920.png"></p><h2 id="如何理解面向接口编程"><a href="#如何理解面向接口编程" class="headerlink" title="如何理解面向接口编程"></a>如何理解面向接口编程</h2><p>这种问题要从接口的意义来讨论，接口的意义在于解耦，解耦的是什么呢？自然是规范与实现，接口本身可以认为是稳定的规范，实现逻辑则认为是不稳定的实现，面向接口编程本质目地是依赖稳定，屏蔽不稳定。</p><p>面向接口编程，对于开发人员有一定要求，接口作为稳定的存在，则要求开发人员定义接口时，要充分屏蔽相关实现细节，比如要定义一个上传文件接口，那么upload(target)，比uploadAliyun()更加合适，因为其没有包含细节，开发人员需要具有接口意识。</p><h2 id="如何理解多用组合少用继承"><a href="#如何理解多用组合少用继承" class="headerlink" title="如何理解多用组合少用继承"></a>如何理解多用组合少用继承</h2><p>常见的编程原则中有组合优于继承这一说法，在《Effective Java》中也有类似说法，作者举出了一个继承HashMap的例子，因为实现类不了解HashMap中addAll方法调用了add方法，导致复写时出现重复计算，来表明继承的缺陷，近而引出了组合设计思路。在复杂多层次的继承关系描述上，组合能够让结构更加简单，没有了复杂的对象关系存在，开发人员更加容易理解业务，这是组合优于继承的一点。<br>但是继承真的该被抛弃吗？当然不是，我们使用的都是面向对象语言，写的都是面向对象代码，继承能很好的描述对象之间的关系，组合却很难做到这一点，这是继承的优势，那问题到底出在哪里？问题的本质原因是<strong>继承的滥用</strong>，比如存在复杂的继承关系树，甚至关系网，继承本意是让你可以更快的了解对象关系，但是这种关系网的存在反而带来的理解障碍，那么此时继承就是不合理的实现方式。再比如类似HashMap这种不是为继承设计的类，但有业务去继承，一不小心就会因为对父类中实现不了解而踩坑。因此对于继承，一般策略是<strong>要么专门为继承设计，要么不使用继承，如果使用继承，那么层次不要超过3层</strong>。</p><p>这一点很好理解，在现在框架中有很多类似的做法，比如Abstract&#x2F;Base开头的类在Spring中经常出现，如下图所示，<code>AbstractThemeResolver</code>就是专门为继承设计的类，这种的好处很明显，结构简单，叶子节点都是实现类，非叶子节点都是抽象类或者接口，关系也简单明了。因此我们在设计时，应尽量遵循树根为接口，中间非叶子节点为抽象类，叶子节点永远是具体实现类方式来设计，让自己的代码变得更加清晰。<br><img src="http://res.mrdear.cn/1588681484.png"></p><p>编程没有统一的标准，如果有什么想法欢迎评论区讨论</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近在极客时间学习设计模式时，回顾了下抽象类与接口的设计意义，以及如何决定什么时候使用抽象类或者接口，写了两三年代码，也算有点想法，本文分享下自己的观点。&lt;/p&gt;
&lt;h2 id=&quot;接口与抽象类的意义&quot;&gt;&lt;a href=&quot;#接口与抽象类的意义&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="夯实Java基础" scheme="https://mrdear.cn/categories/%E5%A4%AF%E5%AE%9EJava%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java" scheme="https://mrdear.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>实践 -- 项目日志配置经验分享</title>
    <link href="https://mrdear.cn/posts/work-how_config_log.html"/>
    <id>https://mrdear.cn/posts/work-how_config_log.html</id>
    <published>2020-03-29T09:20:38.000Z</published>
    <updated>2020-03-29T09:20:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>Java中日志生态是比较乱的，因此在项目中如何使用日志成了一个开发者必须考虑的问题，本文针对工作中日志包使用做一个总结。</p><h2 id="日志分类"><a href="#日志分类" class="headerlink" title="日志分类"></a>日志分类</h2><p>日志包虽然很多，但大体上分为三类</p><ul><li>门面日志类，代表为SLF4J，JCL，其存在的目地是统一应用调用输出日志方式。</li><li>日志实现类，代表为Log4j，Logback，Log4j2等，其真正拥有日志输出能力。</li><li>桥接类：代表为slf4j-log4j12，log4j-slf4j-impl等相关包，其目地是在其他jar强引用第三方日志实现包的情况下，桥接相关第三方日志到应用本身日志实现。</li></ul><p>那么最佳实践自然是一套门面，一套实现，其他都为桥接，如下图所示，这种方式下结构非常清晰，且日志实现类可以随时更换，不会影响到现有应用，目前主流组合有 slf4j + logback + 各种桥接，slf4j + log4j2 + 各种桥接，配置时可以作为参考。<br>也因此日志该如何配置即变成了如何保证应用中有且仅有一套门面，一套实现日志框架。</p><p><img src="http://res.mrdear.cn/1585407394.png"></p><h2 id="门面日志以及桥接的实现原理"><a href="#门面日志以及桥接的实现原理" class="headerlink" title="门面日志以及桥接的实现原理"></a>门面日志以及桥接的实现原理</h2><p>在分析之前，我们大致可以想象到，门面日志相当于定义了一套输出日志的标准API，桥接类相当于复写了对应实现类，然后在内部将对应日志行为转接到slf4j，接下来以slf4j+log4j2为例，描述这一流程。</p><h3 id="Slf4j如何绑定实现类日志"><a href="#Slf4j如何绑定实现类日志" class="headerlink" title="Slf4j如何绑定实现类日志"></a>Slf4j如何绑定实现类日志</h3><p>如下代码所示，在slf4j中<code>org.slf4j.LoggerFactory#bind</code>方法会使用<code>StaticLoggerBinder.getSingleton()</code>完成实现类日志绑定，而<code>StaticLoggerBinder</code>由对应实现类日志提供，比如使用log4j2实现时，则由<code>log4j-slf4j-impl</code>jar提供该类。</p><p><strong>清单一： slf4j日志绑定</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;URL&gt; staticLoggerBinderPathSet = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 检查是否存在多个实现类,存在则报警</span></span><br><span class="line"><span class="keyword">if</span> (!isAndroid()) &#123;</span><br><span class="line">    staticLoggerBinderPathSet = findPossibleStaticLoggerBinderPathSet();</span><br><span class="line">    reportMultipleBindingAmbiguity(staticLoggerBinderPathSet);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 完成日志实现类绑定</span></span><br><span class="line">StaticLoggerBinder.getSingleton();</span><br><span class="line"><span class="comment">// 置为绑定成功状态</span></span><br><span class="line">INITIALIZATION_STATE = SUCCESSFUL_INITIALIZATION;</span><br><span class="line">reportActualBinding(staticLoggerBinderPathSet);</span><br></pre></td></tr></table></figure><p>桥接的目地是获取到<code>ILoggerFactory</code>，由其提供对应日志类<code>Logger</code>，完成绑定输出。</p><h3 id="桥接类如何到Slf4j"><a href="#桥接类如何到Slf4j" class="headerlink" title="桥接类如何到Slf4j"></a>桥接类如何到Slf4j</h3><p>不同的类桥接方式不太一样，以JUL为例，其桥接包<code>jul-to-slf4j</code>提供了<code>SLF4JBridgeHandler</code>类，该类继承了<code>java.util.logging.Handler</code>，针对JUL日志的日志输出会转到<code>org.slf4j.Logger</code>输出，从而实现了桥接。另外<code>log4j-over-slf4j</code>的实现方式，则是完全复写log4j库，提供一样的Class接口，但是内部日志输出使用的是<code>org.slf4j.Logger</code>，从而完成了桥接。</p><p>原理实际上很简单，这其中容易配错的就是桥接方向，比如同时引入了 jcl-over-slf4j 与 slf4j-jcl，前者是桥接jcl到slf4j，后者是桥接slf4j到jcl，那么必然<strong>死循环</strong>，造成内存溢出。</p><h3 id="如何配置日志"><a href="#如何配置日志" class="headerlink" title="如何配置日志"></a>如何配置日志</h3><p>按照一套门面，一套实现，其他都为桥接的标准，日志配置可以分为三个步骤：第一步，引入门面日志框架；第二步，排除多余的日志实现类框架；第三步，引入相关桥接包，排除多余桥接包。按照简单的三个步骤策略，可以轻松配置日志，另外在整个过程中可以画图辅助，这样能够快速帮助你定位到问题所在。</p><h2 id="日志怎么管理"><a href="#日志怎么管理" class="headerlink" title="日志怎么管理"></a>日志怎么管理</h2><p>解决日志配置问题后，管理也是个大问题，随着应用迭代增多，如果不加以控制，日志文件实际上会越来越多，因此收口到一个工具类是非常必要的选择。比如针对报警事件，可以收口到一个alarm.log的日志，使用不同的marker区分，针对监控日志可以收口到monitor.log，使用marker区分，错误日志则全部收口到error.log，防止多处打印。<br>工具类实现，首推策略枚举模式，管理方便，调用简单，还便于在日志上增加各种属性配置，如清单二代码实例所示，该LogUtils不但提供了枚举调用方式，还提供了静态方法调用方式，方便外部存在 logger对象时调用，另外还可以通过匿名类方式，为单一日志对象提供额外方法，灵活性可以说极其自由。</p><p><strong>清单二：策略枚举实现日志工具类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">LogUtils</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通用监控日志</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    MONITOR(LoggerFactory.getLogger(<span class="string">&quot;monitor&quot;</span>)),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通用报警日志</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ALARM(LoggerFactory.getLogger(<span class="string">&quot;alarm&quot;</span>)),</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Logger logger;</span><br><span class="line">    </span><br><span class="line">    LogUtils(Logger logger) &#123;</span><br><span class="line">        <span class="built_in">this</span>.logger = logger;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输出info日志</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msgTemplate 日志模板</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> params 日志参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">(String msgTemplate, Object... params)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">            logger.info(msgTemplate, params);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输出info日志</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msgTemplate 日志模板</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> params 日志参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">(Marker marker, String msgTemplate, Object... params)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">            logger.info(msgTemplate, params);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输出error日志</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msgTemplate 日志模板</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> params 日志参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">error</span><span class="params">(String msgTemplate, Object... params)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isErrorEnabled()) &#123;</span><br><span class="line">            logger.error(msgTemplate, params);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输出info日志</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> logger 日志文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msgTemplate 日志模板</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> params 日志参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">(Logger logger, String msgTemplate, Object... params)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">            logger.info(msgTemplate, params);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输出error日志</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> logger 日志文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msgTemplate 日志模板</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> params 日志参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">error</span><span class="params">(Logger logger, String msgTemplate, Object... params)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isErrorEnabled()) &#123;</span><br><span class="line">            logger.error(msgTemplate, params);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">。。。。。等方法</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>日志配置实际上并没有很多可以说的东西，只要理解了日志体系，配置是很简单的事情，希望本文对你有帮助。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Java中日志生态是比较乱的，因此在项目中如何使用日志成了一个开发者必须考虑的问题，本文针对工作中日志包使用做一个总结。&lt;/p&gt;
&lt;h2 id=&quot;日志分类&quot;&gt;&lt;a href=&quot;#日志分类&quot; class=&quot;headerlink&quot; title=&quot;日志分类&quot;&gt;&lt;/a&gt;日志分类&lt;/</summary>
      
    
    
    
    <category term="实战总结" scheme="https://mrdear.cn/categories/%E5%AE%9E%E6%88%98%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="实战" scheme="https://mrdear.cn/tags/%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>Java -- 字符串常量池介绍</title>
    <link href="https://mrdear.cn/posts/java-string-pool.html"/>
    <id>https://mrdear.cn/posts/java-string-pool.html</id>
    <published>2020-03-15T04:52:08.000Z</published>
    <updated>2020-03-15T04:52:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近看到个案例，twitter工程师在地理位置信息存储上使用<code>String.intern()</code>方法从而节省了大量内存，关键点就是JVM的<code>String Pool</code>，因此本篇文章对<code>String Pool</code>探个究竟。(没看过源码，主要是根据往上资料以及个人理解)</p><h2 id="String-Pool"><a href="#String-Pool" class="headerlink" title="String Pool"></a>String Pool</h2><h3 id="什么是String-Pool"><a href="#什么是String-Pool" class="headerlink" title="什么是String Pool"></a>什么是String Pool</h3><p>JVM所使用的内存中，字符串作为一种特殊的基础数据类型，占据了大量的内存，且字符串有着大量的重复。由于字符串具体不可变性，因此使用<code>String Pool</code>对于同样的字符串做一个缓存，防止多次分配内存，从而提高内存利用率。</p><h3 id="String-Pool是什么结构"><a href="#String-Pool是什么结构" class="headerlink" title="String Pool是什么结构"></a>String Pool是什么结构</h3><p><code>String Pool</code>在JDK当中是一个类似HashTable的结构，其特点线程安全，不可扩容，但是可以rehash<br><img src="http://res.mrdear.cn/1584239599.png?imageMogr2/thumbnail/!60p"></p><h3 id="String-Pool存在什么区域"><a href="#String-Pool存在什么区域" class="headerlink" title="String Pool存在什么区域"></a>String Pool存在什么区域</h3><p>JDK6之前，<code>String Pool</code>存放在永久代，因此大小受到永久代的限制，默认1009大小，且不可更改。从JDK7开始<code>String Pool</code>转移到了堆内存当中，默认大小为60013(用素数降低冲突概率)，此时可以通过<code>-XX:StringTableSize</code>参数进行控制大小，可以使用<code>-XX:+PrintStringTableStatistics</code>参数，让JVM退出时打印出常量池使用情况。</p><h3 id="哪些字符串会放到String-Pool"><a href="#哪些字符串会放到String-Pool" class="headerlink" title="哪些字符串会放到String Pool"></a>哪些字符串会放到String Pool</h3><p>可以把代码中常用的字符串分为三类，然后分别做实验。</p><ol><li>全局变量直接声明(包含静态变量) <code>private static final String STR1 = &quot;world&quot;</code></li><li>局部变量直接申明 <code>String str = &quot;hello&quot;;</code></li><li>程序中动态生成 拼接，读取DB，读取文件等行为</li></ol><p>首先使用一个空Main方法，增加<code>-XX:+PrintStringTableStatistics</code>参数，在IDEA JDK8下，我电脑运行的输出<code>Number of entries</code>一直是840，那么这个就是基础数据了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 代码</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"># 输出</span><br><span class="line">StringTable statistics:</span><br><span class="line">Number of buckets       :     <span class="number">60013</span> =    <span class="number">480104</span> bytes, avg   <span class="number">8.000</span></span><br><span class="line">Number of entries       :       <span class="number">840</span> =     <span class="number">20160</span> bytes, avg  <span class="number">24.000</span></span><br><span class="line">Number of literals      :       <span class="number">840</span> =     <span class="number">57584</span> bytes, avg  <span class="number">68.552</span></span><br></pre></td></tr></table></figure><p>增加局部变量后，常量池大小+1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 代码</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"># 输出</span><br><span class="line">StringTable statistics:</span><br><span class="line">Number of buckets       :     <span class="number">60013</span> =    <span class="number">480104</span> bytes, avg   <span class="number">8.000</span></span><br><span class="line">Number of entries       :       <span class="number">841</span> =     <span class="number">20184</span> bytes, avg  <span class="number">24.000</span></span><br><span class="line">Number of literals      :       <span class="number">841</span> =     <span class="number">57640</span> bytes, avg  <span class="number">68.537</span></span><br></pre></td></tr></table></figure><p>增加静态变量，常量池大小+1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 代码</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">STR</span> <span class="operator">=</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"># 输出</span><br><span class="line">StringTable statistics:</span><br><span class="line">Number of buckets       :     <span class="number">60013</span> =    <span class="number">480104</span> bytes, avg   <span class="number">8.000</span></span><br><span class="line">Number of entries       :       <span class="number">842</span> =     <span class="number">20208</span> bytes, avg  <span class="number">24.000</span></span><br><span class="line">Number of literals      :       <span class="number">842</span> =     <span class="number">57696</span> bytes, avg  <span class="number">68.523</span></span><br></pre></td></tr></table></figure><p>动态拼接，常量池不变</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 代码</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">STR</span> <span class="operator">=</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> Integer.toString(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"># 输出</span><br><span class="line">StringTable statistics:</span><br><span class="line">Number of buckets       :     <span class="number">60013</span> =    <span class="number">480104</span> bytes, avg   <span class="number">8.000</span></span><br><span class="line">Number of entries       :       <span class="number">842</span> =     <span class="number">20208</span> bytes, avg  <span class="number">24.000</span></span><br><span class="line">Number of literals      :       <span class="number">842</span> =     <span class="number">57696</span> bytes, avg  <span class="number">68.523</span></span><br></pre></td></tr></table></figure><p>动态拼接，增加intern调用，常量池+10</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 代码</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">STR</span> <span class="operator">=</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> Integer.toString(i).intern();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"># 输出</span><br><span class="line">StringTable statistics:</span><br><span class="line">Number of buckets       :     <span class="number">60013</span> =    <span class="number">480104</span> bytes, avg   <span class="number">8.000</span></span><br><span class="line">Number of entries       :       <span class="number">852</span> =     <span class="number">20448</span> bytes, avg  <span class="number">24.000</span></span><br><span class="line">Number of literals      :       <span class="number">852</span> =     <span class="number">58176</span> bytes, avg  <span class="number">68.282</span></span><br></pre></td></tr></table></figure><p>那么从我这个不专业的测试，可以得出结论，如有疑议可以评论中讨论哈。</p><ol><li>字面字符串常量会进入到字符串常量池</li><li>代码中动态生成的字符串不会进入常量池</li><li>intern可以主动让字符串进入常量池</li></ol><h3 id="常见问题解释"><a href="#常见问题解释" class="headerlink" title="常见问题解释"></a>常见问题解释</h3><p><strong>1.String str4 &#x3D; new String(“abc”)执行过程？</strong></p><p>通过反编译以及常量池输出，可以看出结论，常量池+1，不包括常量池的话，对象也是+1，流程是先创建(new)一个String对象，压入(dup)到栈顶，然后从常量池中(ldc)初始化abd字符串，调用构造函数初始化(invokespecial)对象，最后将对象引用赋值(astore_1)给本地变量str4。反编译插件可以使用<a href="https://mrdear.cn/posts/idea_plugin_decompile.html">IDEA插件 – Class Decompile</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 反编译结果</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">2</span>                  <span class="comment">// class java/lang/String</span></span><br><span class="line">       <span class="number">3</span>: dup</span><br><span class="line">       <span class="number">4</span>: ldc           #<span class="number">3</span>                  <span class="comment">// String abc</span></span><br><span class="line">       <span class="number">6</span>: invokespecial #<span class="number">4</span>                  <span class="comment">// Method java/lang/String.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V</span></span><br><span class="line">       <span class="number">9</span>: astore_1</span><br><span class="line">      <span class="number">10</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"># 常量池输出</span><br><span class="line">StringTable statistics:</span><br><span class="line">Number of buckets       :     <span class="number">60013</span> =    <span class="number">480104</span> bytes, avg   <span class="number">8.000</span></span><br><span class="line">Number of entries       :       <span class="number">841</span> =     <span class="number">20184</span> bytes, avg  <span class="number">24.000</span></span><br><span class="line">Number of literals      :       <span class="number">841</span> =     <span class="number">57632</span> bytes, avg  <span class="number">68.528</span></span><br></pre></td></tr></table></figure><p><strong>2.JDK6与JDK7下不同代码结果差异</strong></p><p>往上常见的题目如下，JDK6下<code>false，false</code>，JDK7下<code>false，true</code>，那么本质原因我认为是字符串常量池所在位置调整导致，JDK6时，字符串常量池位于永久代，因此对象也直接在永久代分配，由于永久代不会很大，所以所以大小被限制在1009。那么同一个对象，intern进入到常量池后，实际上会在永久代创建一个新的对象。而JDK7下，字符串常量池转移到堆中，不再有容量限制问题，因此可以直接利用堆中已经存在的对象(S4就是直接使用了S3对象)，而不需要重新创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>); # 该对象创建出来时，常量池已经有<span class="number">1</span>存在</span><br><span class="line">    s.intern();</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    System.out.println(s == s2);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>); # 与s最大的不同，是该对象创建出来时，常量池并没有存在<span class="number">11</span></span><br><span class="line">    s3.intern();</span><br><span class="line">    <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;11&quot;</span>;</span><br><span class="line">    System.out.println(s3 == s4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="intern使用技巧"><a href="#intern使用技巧" class="headerlink" title="intern使用技巧"></a>intern使用技巧</h2><p><code>String Pool</code>的本意是缓存高复用的字符串对象，从而节省大量内存，那么遵从本意就是合理使用。</p><p>举个例子，假设某一业务需要在服务端Session中保存用户的地理位置信息(省，市，县)，那么地理位置信息就属于高复用字符串对象，使用intern必定会节省大量内存消耗。再举个反例，某中间件做链路追踪时，生成的traceId，误调用了intern方法，那么结果会导致字符串常量池越来越大，YGC时扫描的对象越来越多，从而导致线上YGC越来越耗时，最终引发故障。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.javadoop.com/post/string">Java 字符串常量池介绍</a></li><li><a href="http://lovestblog.cn/blog/2016/11/06/string-intern/">JVM源码分析之String.intern()导致的YGC不断变长</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近看到个案例，twitter工程师在地理位置信息存储上使用&lt;code&gt;String.intern()&lt;/code&gt;方法从而节省了大量内存，关键点就是JVM的&lt;code&gt;String Pool&lt;/code&gt;，因此本篇文章对&lt;code&gt;String Pool&lt;/code&gt;探个</summary>
      
    
    
    
    <category term="夯实Java基础" scheme="https://mrdear.cn/categories/%E5%A4%AF%E5%AE%9EJava%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java" scheme="https://mrdear.cn/tags/Java/"/>
    
  </entry>
  
</feed>
